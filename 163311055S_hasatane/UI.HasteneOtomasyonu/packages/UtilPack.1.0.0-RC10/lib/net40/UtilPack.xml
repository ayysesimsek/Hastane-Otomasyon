<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>UtilPack</name>
  </assembly>
  <members>
    <member name="T:UtilPack.AbstractDisposable">
      <summary>
            Provides skeleton implementation of dispose pattern in .NET.
            It will ensure dispose is called exactly once even in concurrent scenarios.
            </summary>
    </member>
    <member name="M:UtilPack.AbstractDisposable.Dispose">
      <inheritdoc />
    </member>
    <member name="M:UtilPack.AbstractDisposable.Dispose(System.Boolean)">
      <summary>
            This method should do the actual disposing logic.
            </summary>
      <param name="disposing">
        <c>true</c> if this is called from <see cref="M:UtilPack.AbstractDisposable.Dispose" /> method; <c>false</c> if this is called from destructor.</param>
    </member>
    <member name="M:UtilPack.AbstractDisposable.ThrowIfDisposed(System.String)">
      <summary>
            Throws an <see cref="T:System.ObjectDisposedException" /> with optional given message, if this <see cref="T:UtilPack.AbstractDisposable" /> is disposed.
            </summary>
      <param name="msg">The optional message. The default message will be used if this is not given.</param>
    </member>
    <member name="P:UtilPack.AbstractDisposable.Disposed">
      <summary>
            Gets value whether this object has been disposed.
            </summary>
      <value>Whether this object has been disposed.</value>
    </member>
    <member name="M:UtilPack.AbstractDisposable.Finalize">
      <summary>
            This destructor will call the <see cref="M:UtilPack.AbstractDisposable.Dispose(System.Boolean)" /> with <c>false</c> as parameter.
            </summary>
      <remarks>
            This destructor will silently discard any exceptions that are thrown within <see cref="M:UtilPack.AbstractDisposable.Dispose(System.Boolean)" /> method.
            </remarks>
    </member>
    <member name="T:UtilPack.ArgumentValidator">
      <summary>
            Helper class to easily verify whether some method parameter is <c>null</c> or empty.
            </summary>
    </member>
    <member name="M:UtilPack.ArgumentValidator.ValidateNotNull``1(System.String,``0)">
      <summary>
            Checks whether a method parameter is <c>null</c>.
            </summary>
      <typeparam name="T">Type of parameter, must be class; to ensure that this method won't be called for struct parameters.</typeparam>
      <param name="parameterName">The name of the parameter.</param>
      <param name="value">The given parameter.</param>
      <returns>The <paramref name="value" />.</returns>
      <exception cref="T:System.ArgumentNullException">If the <paramref name="value" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.ArgumentValidator.ValidateNotNullReference``1(``0)">
      <summary>
            Checks whether the <c>this</c> parameter for extension method is <c>null</c>.
            </summary>
      <typeparam name="T">Type of parameter, must be class; to ensure that this method won't be called for struct parameters.</typeparam>
      <param name="value">The <c>this</c> parameter.</param>
      <returns>The <paramref name="value" /></returns>
      <exception cref="T:System.NullReferenceException">If <paramref name="value" /> is <c>null</c>.</exception>
      <remarks>
            This method throws <see cref="T:System.NullReferenceException" /> instead of <see cref="T:System.ArgumentNullException" /> because it is intended to be used solely as validating the <c>this</c> parameter of an extension method.
            If the extension method is later added to the interface itself instead of being an extension method, the exception behaviour will not change, and the client code don't need to re-adapt their catch-handlers.
            </remarks>
    </member>
    <member name="M:UtilPack.ArgumentValidator.ValidateNotEmpty``1(System.String,System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Checks whether given enumerable parameter has any elements.
            </summary>
      <typeparam name="T">The type of the enumerable element.</typeparam>
      <param name="parameterName">The name of the parameter.</param>
      <param name="value">The given parameter.</param>
      <returns>The <paramref name="value" />.</returns>
      <exception cref="T:System.ArgumentNullException">If the <paramref name="value" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If the <paramref name="value" /> is empty.</exception>
    </member>
    <member name="M:UtilPack.ArgumentValidator.ValidateNotEmpty``1(System.String,``0[])">
      <summary>
            Checks whether given array parameter has any elements. Is somewhat faster than the <see cref="M:UtilPack.ArgumentValidator.ValidateNotEmpty``1(System.String,System.Collections.Generic.IEnumerable{``0})" />.
            </summary>
      <typeparam name="T">The type of the array element.</typeparam>
      <param name="parameterName">The name of the parameter</param>
      <param name="value">The given parameter</param>
      <returns>The <paramref name="value" />.</returns>
      <exception cref="T:System.ArgumentNullException">If the <paramref name="value" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If the <paramref name="value" /> is empty.</exception>
    </member>
    <member name="M:UtilPack.ArgumentValidator.ValidateNotEmpty(System.String,System.String)">
      <summary>
            Checks whether given string parameter contains any characters.
            </summary>
      <param name="parameterName">The name of the parameter</param>
      <param name="value">The given parameter</param>
      <returns>The <paramref name="value" />.</returns>
      <exception cref="T:System.ArgumentNullException">If the <paramref name="value" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If the <paramref name="value" /> is empty.</exception>
    </member>
    <member name="M:UtilPack.ArgumentValidator.ValidateAllNotNull``1(System.String,System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Checks that <paramref name="values" /> is not <c>null</c>, and that all items in <paramref name="values" /> are not nulls either.
            Will enumerate the <paramref name="values" /> once.
            </summary>
      <typeparam name="T">The type of items.</typeparam>
      <param name="parameterName">The name of the parameter.</param>
      <param name="values">The given paramter.</param>
      <returns>The <paramref name="values" />.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="values" /> is <c>null</c>, or if it contains at least one <c>null</c> item.</exception>
    </member>
    <member name="T:UtilPack.UtilPackExtensions">
      <summary>
            This class contains extension method which are for types not contained in this library.
            </summary>
      <summary>
            Extension method holder to enumerate graphs as depth first IEnumerables and breadth first IEnumerables. Additionally contains method to enumerate single chain as enumerable.
            </summary>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.SeekFromCurrent(System.IO.Stream,System.Int64)">
      <summary>
            This is alias for <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" /> method with <see cref="F:System.IO.SeekOrigin.Current" /> as second parameter.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" />.</param>
      <param name="amount">How many bytes to advance or go back.</param>
      <returns>The <paramref name="stream" />.</returns>
      <exception cref="T:System.NullReferenceException">If <paramref name="stream" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.SeekFromBegin(System.IO.Stream,System.Int64)">
      <summary>
            This is alias for <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" /> method with <see cref="F:System.IO.SeekOrigin.Begin" /> as second parameter.
            </summary>
      <param name="stream">The <see cref="T:System.IO.Stream" />.</param>
      <param name="position">How many bytes to seek from the beginning.</param>
      <returns>The <paramref name="stream" />.</returns>
      <exception cref="T:System.NullReferenceException">If <paramref name="stream" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadByteFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads a single byte at specified index in byte array.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index to read byte at. Will be incremented by one.</param>
      <returns>The byte at specified index.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadSByteFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads a single byte as <see cref="T:System.SByte" /> at specified index in byte array.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index to read byte at. Will be incremented by one.</param>
      <returns>The byte at specified index casted to <see cref="T:System.SByte" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt16LEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads <see cref="T:System.Int16" /> starting at specified index in byte array using little-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 2.</param>
      <returns>The decoded <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt16LEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads <see cref="T:System.Int16" /> starting at specified index in byte array using little-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt16LEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads <see cref="T:System.UInt16" /> starting at specified index in byte array using little-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 2.</param>
      <returns>The decoded <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt16LEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads <see cref="T:System.UInt16" /> starting at specified index in byte array using little-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt32LEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads <see cref="T:System.Int32" /> starting at specified index in byte array using little-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 4.</param>
      <returns>The decoded <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt32LEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads <see cref="T:System.Int32" /> starting at specified index in byte array using little-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>Decoded <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt32LEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads <see cref="T:System.UInt32" /> starting at specified index in byte array using little-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 4.</param>
      <returns>The decoded <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt32LEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads <see cref="T:System.UInt32" /> starting at specified index in byte array using little-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt64LEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads <see cref="T:System.Int64" /> starting at specified index in byte array using little-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 8.</param>
      <returns>The decoded <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt64LEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads <see cref="T:System.Int64" /> starting at specified index in byte array using little-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt64LEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads <see cref="T:System.Int64" /> starting at specified index in byte array using little-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 8.</param>
      <returns>The decoded <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt64LEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads <see cref="T:System.Int64" /> starting at specified index in byte array using little-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadSingleLEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads Int32 bits starting at specified index in byte array in little-endian order and changes value to <see cref="T:System.Single" />.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 4.</param>
      <returns>The decoded <see cref="T:System.Single" />.</returns>
      <exception cref="T:System.NullReferenceException">If <paramref name="array" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadSingleLEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads Int32 bits starting at specified index in byte array in little-endian order and changes value to <see cref="T:System.Single" />.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.Single" />.</returns>
      <exception cref="T:System.NullReferenceException">If <paramref name="array" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadDoubleLEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads Int64 bits starting at specified index in byte array in little-endian order and changes value to <see cref="T:System.Double" />.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 8.</param>
      <returns>The decoded <see cref="T:System.Double" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadDoubleLEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads Int64 bits starting at specified index in byte array in little-endian order and changes value to <see cref="T:System.Double" />.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.Double" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt32ArrayLEFromBytes(System.Byte[],System.Int32@,System.Int32)">
      <summary>
            Reads given amount of integers from byte array starting at given offset, and returns the integers as array.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start reading. It will be incremented by <paramref name="intArrayLen" /> * 4.</param>
      <param name="intArrayLen">The amount of integers to read.</param>
      <returns>The integer array.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt32ArrayLEFromBytes(System.Byte[],System.Int32@,System.Int32)">
      <summary>
            Reads given amount of unsigned integers from byte array starting at given offset, and returns the unsigned integers as array.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start reading. It will be incremented by <paramref name="intArrayLen" /> * 4.</param>
      <param name="intArrayLen">The amount of unsigned integers to read.</param>
      <returns>The unsigned integer array.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt16LEToBytes(System.Byte[],System.Int32@,System.Int16)">
      <summary>
            Writes a given <see cref="T:System.Int16" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 2.</param>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt16LEToBytesNoRef(System.Byte[],System.Int32,System.Int16)">
      <summary>
            Writes a given <see cref="T:System.Int16" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteUInt16LEToBytes(System.Byte[],System.Int32@,System.UInt16)">
      <summary>
            Writes a given <see cref="T:System.UInt16" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 2.</param>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteUInt16LEToBytesNoRef(System.Byte[],System.Int32,System.UInt16)">
      <summary>
            Writes a given <see cref="T:System.UInt16" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt32LEToBytes(System.Byte[],System.Int32@,System.Int32)">
      <summary>
            Writes a given <see cref="T:System.Int32" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 4.</param>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt32LEToBytesNoRef(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Writes a given <see cref="T:System.Int32" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteUInt32LEToBytes(System.Byte[],System.Int32@,System.UInt32)">
      <summary>
            Writes a given <see cref="T:System.UInt32" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 4.</param>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteUInt32LEToBytesNoRef(System.Byte[],System.Int32,System.UInt32)">
      <summary>
            Writes a given <see cref="T:System.UInt32" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt64LEToBytes(System.Byte[],System.Int32@,System.Int64)">
      <summary>
            Writes a given <see cref="T:System.Int64" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 8.</param>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt64LEToBytesNoRef(System.Byte[],System.Int32,System.Int64)">
      <summary>
            Writes a given <see cref="T:System.Int64" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteUInt64LEToBytes(System.Byte[],System.Int32@,System.UInt64)">
      <summary>
            Writes a given <see cref="T:System.UInt64" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 8.</param>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteUInt64LEToBytesNoRef(System.Byte[],System.Int32,System.UInt64)">
      <summary>
            Writes a given <see cref="T:System.UInt64" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteSingleLEToBytes(System.Byte[],System.Int32@,System.Single)">
      <summary>
            Writes Int32 bits of given <see cref="T:System.Single" /> value in little-endian orger to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 4.</param>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteSingleLEToBytesNoRef(System.Byte[],System.Int32,System.Single)">
      <summary>
            Writes Int32 bits of given <see cref="T:System.Single" /> value in little-endian orger to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteDoubleLEToBytes(System.Byte[],System.Int32@,System.Double)">
      <summary>
            Writes Int64 bits of given <see cref="T:System.Double" /> value in little-endian order to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 8.</param>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteDoubleLEToBytesNoRef(System.Byte[],System.Int32,System.Double)">
      <summary>
            Writes Int64 bits of given <see cref="T:System.Double" /> value in little-endian order to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt16BEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads <see cref="T:System.Int16" /> starting at specified index in byte array using big-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 2.</param>
      <returns>The decoded <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt16BEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads <see cref="T:System.Int16" /> starting at specified index in byte array using big-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt16BEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads <see cref="T:System.UInt16" /> starting at specified index in byte array using big-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 2.</param>
      <returns>The decoded <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt16BEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads <see cref="T:System.UInt16" /> starting at specified index in byte array using big-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt32BEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads <see cref="T:System.Int32" /> starting at specified index in byte array using big-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 4.</param>
      <returns>The decoded <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt32BEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads <see cref="T:System.Int32" /> starting at specified index in byte array using big-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>Decoded <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt32BEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads <see cref="T:System.UInt32" /> starting at specified index in byte array using big-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 4.</param>
      <returns>The decoded <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt32BEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads <see cref="T:System.UInt32" /> starting at specified index in byte array using big-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt64BEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads <see cref="T:System.Int64" /> starting at specified index in byte array using big-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 8.</param>
      <returns>The decoded <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt64BEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads <see cref="T:System.Int64" /> starting at specified index in byte array using big-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt64BEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads <see cref="T:System.Int64" /> starting at specified index in byte array using big-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 8.</param>
      <returns>The decoded <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt64BEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads <see cref="T:System.Int64" /> starting at specified index in byte array using big-endian decoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadSingleBEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads Int32 bits starting at specified index in byte array in big-endian order and changes value to <see cref="T:System.Single" />.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 4.</param>
      <returns>The decoded <see cref="T:System.Single" />.</returns>
      <exception cref="T:System.NullReferenceException">If <paramref name="array" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadSingleBEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads Int32 bits starting at specified index in byte array in big-endian order and changes value to <see cref="T:System.Single" />.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.Single" />.</returns>
      <exception cref="T:System.NullReferenceException">If <paramref name="array" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadDoubleBEFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads Int64 bits starting at specified index in byte array in big-endian order and changes value to <see cref="T:System.Double" />.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading. Will be incremented by 8.</param>
      <returns>The decoded <see cref="T:System.Double" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadDoubleBEFromBytesNoRef(System.Byte[],System.Int32)">
      <summary>
            Reads Int64 bits starting at specified index in byte array in big-endian order and changes value to <see cref="T:System.Double" />.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index of array to start reading.</param>
      <returns>The decoded <see cref="T:System.Double" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt32ArrayBEFromBytes(System.Byte[],System.Int32@,System.Int32)">
      <summary>
            Reads given amount of integers from byte array starting at given offset, and returns the integers as array.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start reading. It will be incremented by <paramref name="intArrayLen" /> * 4.</param>
      <param name="intArrayLen">The amount of integers to read.</param>
      <returns>The integer array.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadUInt32ArrayBEFromBytes(System.Byte[],System.Int32@,System.Int32)">
      <summary>
            Reads given amount of unsigned integers from byte array starting at given offset, and returns the unsigned integers as array.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start reading. It will be incremented by <paramref name="intArrayLen" /> * 4.</param>
      <param name="intArrayLen">The amount of unsigned integers to read.</param>
      <returns>The unsigned integer array.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt16BEToBytes(System.Byte[],System.Int32@,System.Int16)">
      <summary>
            Writes a given <see cref="T:System.Int16" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 2.</param>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt16BEToBytesNoRef(System.Byte[],System.Int32,System.Int16)">
      <summary>
            Writes a given <see cref="T:System.Int16" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteUInt16BEToBytes(System.Byte[],System.Int32@,System.UInt16)">
      <summary>
            Writes a given <see cref="T:System.UInt16" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 2.</param>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteUInt16BEToBytesNoRef(System.Byte[],System.Int32,System.UInt16)">
      <summary>
            Writes a given <see cref="T:System.UInt16" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt32BEToBytes(System.Byte[],System.Int32@,System.Int32)">
      <summary>
            Writes a given <see cref="T:System.Int32" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 4.</param>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt32BEToBytesNoRef(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Writes a given <see cref="T:System.Int32" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteUInt32BEToBytes(System.Byte[],System.Int32@,System.UInt32)">
      <summary>
            Writes a given <see cref="T:System.UInt32" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 4.</param>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteUInt32BEToBytesNoRef(System.Byte[],System.Int32,System.UInt32)">
      <summary>
            Writes a given <see cref="T:System.UInt32" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt64BEToBytes(System.Byte[],System.Int32@,System.Int64)">
      <summary>
            Writes a given <see cref="T:System.Int64" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 8.</param>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt64BEToBytesNoRef(System.Byte[],System.Int32,System.Int64)">
      <summary>
            Writes a given <see cref="T:System.Int64" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteUInt64BEToBytes(System.Byte[],System.Int32@,System.UInt64)">
      <summary>
            Writes a given <see cref="T:System.UInt64" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 8.</param>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteUInt64BEToBytesNoRef(System.Byte[],System.Int32,System.UInt64)">
      <summary>
            Writes a given <see cref="T:System.UInt64" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteSingleBEToBytes(System.Byte[],System.Int32@,System.Single)">
      <summary>
            Writes Int32 bits of given <see cref="T:System.Single" /> value in big-endian orger to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 4.</param>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteSingleBEToBytesNoRef(System.Byte[],System.Int32,System.Single)">
      <summary>
            Writes Int32 bits of given <see cref="T:System.Single" /> value in big-endian orger to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteDoubleBEToBytes(System.Byte[],System.Int32@,System.Double)">
      <summary>
            Writes Int64 bits of given <see cref="T:System.Double" /> value in big-endian order to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 8.</param>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteDoubleBEToBytesNoRef(System.Byte[],System.Int32,System.Double)">
      <summary>
            Writes Int64 bits of given <see cref="T:System.Double" /> value in big-endian order to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadASCIIStringFromBytes(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Reads a string starting at specified index in byte array, assuming that each byte is an ASCII character.
            </summary>
      <param name="array">The byte array.</param>
      <param name="offset">The offset to start reading.</param>
      <param name="length">The amount of bytes to read.</param>
      <returns>ASCII-encoded string with <paramref name="length" /> characters.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadZeroTerminatedStringFromBytes(System.Byte[],System.Int32@,System.Text.Encoding)">
      <summary>
            Reads a string starting at specified index in byte array, assuming that the string will be terminated by zero byte or by the array ending.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start reading. This will be incremented by amount of bytes read, including the zero byte.</param>
      <param name="encoding">The encoding to use to decode string.</param>
      <returns>The decoded string.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="encoding" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadStringWithEncoding(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)">
      <summary>
            Reads a string at specified index in byte array using specified <see cref="T:System.Text.Encoding" />.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start reading. This will be incremeted by <paramref name="byteLen" />.</param>
      <param name="byteLen">The amount of bytes to read.</param>
      <param name="encoding">The <see cref="T:System.Text.Encoding" /> to use.</param>
      <returns>The string decoded using a given <paramref name="encoding" />.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="encoding" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadGUIDFromBytes(System.Byte[],System.Int32@)">
      <summary>
            Reads a <see cref="T:System.Guid" /> from specified offset in byte array.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start reading. Will be incremented by 16.</param>
      <returns>The decoded <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteByteToBytes(System.Byte[],System.Int32@,System.Byte)">
      <summary>
            Sets a single byte in byte array at specified offset to given value, and increments the offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to set byte. Will be incremented by 1.</param>
      <param name="aByte">The value to set.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteSByteToBytes(System.Byte[],System.Int32@,System.SByte)">
      <summary>
            Sets a single byte in byte array at specified offset to given value, and increments the offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to set byte. Will be incremented by 1.</param>
      <param name="sByte">The value to set. Even though it is integer, it is interpreted as signed byte.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteStringToBytes(System.Byte[],System.Int32@,System.Text.Encoding,System.String)">
      <summary>
            Writes a given string in byte array starting at specified offset and using specified <see cref="T:System.Text.Encoding" />.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by the amount of bytes the <paramref name="str" /> will take using the <paramref name="encoding" />.</param>
      <param name="encoding">The <see cref="T:System.Text.Encoding" /> to use.</param>
      <param name="str">The string to write.</param>
      <returns>The <paramref name="array" />.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="encoding" /> or <paramref name="str" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteGUIDToBytes(System.Byte[],System.Int32@,System.Guid)">
      <summary>
            Writes a given <see cref="T:System.Guid" /> in byte array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by <c>16</c>.</param>
      <param name="guid">The <see cref="T:System.Guid" /> to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.Skip(System.Byte[],System.Int32@,System.Int32)">
      <summary>
            Increments index and returns the array.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The current index. Will be incremented by <paramref name="count" />.</param>
      <param name="count">The amount to increment <paramref name="idx" />.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteASCIIString(System.Byte[],System.Int32@,System.String,System.Boolean)">
      <summary>
            Writes a string using casting each character to <see cref="T:System.Byte" />. Will not throw on invalid bytes.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing at. Will be incremented by the length of <paramref name="str" />.</param>
      <param name="str">The string to write.</param>
      <param name="terminatingZero">Whether to write a terminating zero following the string.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt32LEEncoded7Bit(System.Byte[],System.Int32@,System.Boolean)">
      <summary>
            Reads 7-bit encoded <see cref="T:System.Int32" /> in little-endian format from byte array.
            This kind of variable-length encoding is used by <see cref="T:System.IO.BinaryReader" /> when it deserializes strings.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index in the <paramref name="array" /> where to start to read 7-bit encoded <see cref="T:System.Int32" />. This parameter will be incremented by how many bytes were needed to read the value.</param>
      <param name="throwOnInvalid">
            Whether to throw an <see cref="T:System.InvalidOperationException" /> if the integer has invalid encoded value.
            The value is considered to be encoded in invalid way if fifth byte has its highest bit set.
            </param>
      <returns>The decoded <see cref="T:System.Int32" />.</returns>
      <exception cref="T:System.InvalidOperationException">If the <paramref name="throwOnInvalid" /> is <c>true</c> and fifth read byte has its highest bit set.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt64LEEncoded7Bit(System.Byte[],System.Int32@,System.Boolean)">
      <summary>
            Reads 7-bit encoded <see cref="T:System.Int64" /> in little-endian format from byte array.
            This kind of variable-length encoding is used by <see cref="T:System.IO.BinaryReader" /> when it deserializes strings.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index in the <paramref name="array" /> where to start to read 7-bit encoded <see cref="T:System.Int64" />. This parameter will be incremented by how many bytes were needed to read the value.</param>
      <param name="throwOnInvalid">
            Whether to throw an <see cref="T:System.InvalidOperationException" /> if the integer has invalid encoded value.
            The value is considered to be encoded in invalid way if fifth byte has its highest bit set.
            </param>
      <returns>The decoded <see cref="T:System.Int64" />.</returns>
      <exception cref="T:System.InvalidOperationException">If the <paramref name="throwOnInvalid" /> is <c>true</c> and fifth read byte has its highest bit set.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt32LEEncoded7Bit(System.Byte[],System.Int32@,System.Int32)">
      <summary>
            Writes 7-bit encoded <see cref="T:System.Int32" /> in little-endian format to byte array.
            This kind of variable-length encoding is used by <see cref="T:System.IO.BinaryWriter" /> when it serializes strings.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index in the <paramref name="array" /> where to start to write 7-bit encoded <see cref="T:System.Int32" />. This parameter will be incremented by how many bytes were needed to write the value.</param>
      <param name="value">The value to encode.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt64LEEncoded7Bit(System.Byte[],System.Int32@,System.Int64)">
      <summary>
            Writes 7-bit encoded <see cref="T:System.Int64" /> in little-endian format to byte array.
            This kind of variable-length encoding is used by <see cref="T:System.IO.BinaryWriter" /> when it serializes strings.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index in the <paramref name="array" /> where to start to write 7-bit encoded <see cref="T:System.Int32" />. This parameter will be incremented by how many bytes were needed to write the value.</param>
      <param name="value">The value to encode.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt32BEEncoded7Bit(System.Byte[],System.Int32@,System.Boolean)">
      <summary>
            Reads 7-bit encoded <see cref="T:System.Int32" /> in big-endian format from byte array.
            This kind of variable-length encoding is used by <see cref="T:System.IO.BinaryReader" /> when it deserializes strings.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index in the <paramref name="array" /> where to start to read 7-bit encoded <see cref="T:System.Int32" />. This parameter will be incremented by how many bytes were needed to read the value.</param>
      <param name="throwOnInvalid">
            Whether to throw an <see cref="T:System.InvalidOperationException" /> if the integer has invalid encoded value.
            The value is considered to be encoded in invalid way if fifth byte has its highest bit set.
            </param>
      <returns>The decoded <see cref="T:System.Int32" />.</returns>
      <exception cref="T:System.InvalidOperationException">If the <paramref name="throwOnInvalid" /> is <c>true</c> and fifth read byte has its highest bit set.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadInt64BEEncoded7Bit(System.Byte[],System.Int32@,System.Boolean)">
      <summary>
            Reads 7-bit encoded <see cref="T:System.Int64" /> in big-endian format from byte array.
            This kind of variable-length encoding is used by <see cref="T:System.IO.BinaryReader" /> when it deserializes strings.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index in the <paramref name="array" /> where to start to read 7-bit encoded <see cref="T:System.Int64" />. This parameter will be incremented by how many bytes were needed to read the value.</param>
      <param name="throwOnInvalid">
            Whether to throw an <see cref="T:System.InvalidOperationException" /> if the integer has invalid encoded value.
            The value is considered to be encoded in invalid way if fifth byte has its highest bit set.
            </param>
      <returns>The decoded <see cref="T:System.Int64" />.</returns>
      <exception cref="T:System.InvalidOperationException">If the <paramref name="throwOnInvalid" /> is <c>true</c> and fifth read byte has its highest bit set.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt32BEEncoded7Bit(System.Byte[],System.Int32@,System.Int32)">
      <summary>
            Writes 7-bit encoded <see cref="T:System.Int32" /> in big-endian format to byte array.
            This kind of variable-length encoding is used by <see cref="T:System.IO.BinaryWriter" /> when it serializes strings.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index in the <paramref name="array" /> where to start to write 7-bit encoded <see cref="T:System.Int32" />. This parameter will be incremented by how many bytes were needed to write the value.</param>
      <param name="value">The value to encode.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteInt64BEEncoded7Bit(System.Byte[],System.Int32@,System.Int64)">
      <summary>
            Writes 7-bit encoded <see cref="T:System.Int64" /> in big-endian format to byte array.
            This kind of variable-length encoding is used by <see cref="T:System.IO.BinaryWriter" /> when it serializes strings.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index in the <paramref name="array" /> where to start to write 7-bit encoded <see cref="T:System.Int32" />. This parameter will be incremented by how many bytes were needed to write the value.</param>
      <param name="value">The value to encode.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ZeroOut(System.Byte[],System.Int32@,System.Int32)">
      <summary>
            Fills array with zeroes, starting at specified offset and writing specified amount of zeroes.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index to start. Will be incremented by <paramref name="count" /> when this method finishes.</param>
      <param name="count">The amount of zeroes to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RotateLeft(System.Int32,System.Int32)">
      <summary>
            Rotates given <paramref name="value" /> left <paramref name="shift" /> amount of bytes.
            </summary>
      <param name="value">The value to rotate to left.</param>
      <param name="shift">The amount to bits to rotate.</param>
      <returns>The rotated value.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RotateLeft(System.UInt32,System.Int32)">
      <summary>
            Rotates given <paramref name="value" /> left <paramref name="shift" /> amount of bytes.
            </summary>
      <param name="value">The value to rotate to left.</param>
      <param name="shift">The amount to bits to rotate.</param>
      <returns>The rotated value.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RotateRight(System.Int32,System.Int32)">
      <summary>
            Rotates given <paramref name="value" /> right <paramref name="shift" /> amount of bytes.
            </summary>
      <param name="value">The value to rotate to right.</param>
      <param name="shift">The amount to bits to rotate.</param>
      <returns>The rotated value.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RotateRight(System.UInt32,System.Int32)">
      <summary>
            Rotates given <paramref name="value" /> right <paramref name="shift" /> amount of bytes.
            </summary>
      <param name="value">The value to rotate to right.</param>
      <param name="shift">The amount to bits to rotate.</param>
      <returns>The rotated value.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RotateLeft(System.Int64,System.Int32)">
      <summary>
            Rotates given <paramref name="value" /> left <paramref name="shift" /> amount of bytes.
            </summary>
      <param name="value">The value to rotate to left.</param>
      <param name="shift">The amount to bits to rotate.</param>
      <returns>The rotated value.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RotateLeft(System.UInt64,System.Int32)">
      <summary>
            Rotates given <paramref name="value" /> left <paramref name="shift" /> amount of bytes.
            </summary>
      <param name="value">The value to rotate to left.</param>
      <param name="shift">The amount to bits to rotate.</param>
      <returns>The rotated value.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RotateRight(System.Int64,System.Int32)">
      <summary>
            Rotates given <paramref name="value" /> right <paramref name="shift" /> amount of bytes.
            </summary>
      <param name="value">The value to rotate to right.</param>
      <param name="shift">The amount to bits to rotate.</param>
      <returns>The rotated value.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RotateRight(System.UInt64,System.Int32)">
      <summary>
            Rotates given <paramref name="value" /> right <paramref name="shift" /> amount of bytes.
            </summary>
      <param name="value">The value to rotate to right.</param>
      <param name="shift">The amount to bits to rotate.</param>
      <returns>The rotated value.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RoundUpI32(System.Int32,System.Int32)">
      <summary>
            Rounds given value up to next alignment, which should be a power of two.
            </summary>
      <param name="value">The value.</param>
      <param name="multiple">The alignment.</param>
      <returns>Value rounded up to next alignment.</returns>
      <remarks>
            Will return incorrect results if <paramref name="multiple" /> is zero.
            </remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RoundUpU32(System.UInt32,System.UInt32)">
      <summary>
            Rounds given value up to next alignment, which should be a power of two.
            </summary>
      <param name="value">The value.</param>
      <param name="multiple">The alignment.</param>
      <returns>Value rounded up to next alignment.</returns>
      <remarks>
            Will return incorrect results if <paramref name="multiple" /> is zero.
            </remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RoundUpI64(System.Int64,System.Int64)">
      <summary>
            Rounds given value up to next alignment, which should be a power of two.
            </summary>
      <param name="value">The value.</param>
      <param name="multiple">The alignment.</param>
      <returns>Value rounded up to next alignment.</returns>
      <remarks>
            Will return incorrect results if <paramref name="multiple" /> is zero.
            </remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RoundUpU64(System.UInt64,System.UInt64)">
      <summary>
            Rounds given value up to next alignment, which should be a power of two.
            </summary>
      <param name="value">The value.</param>
      <param name="multiple">The alignment.</param>
      <returns>Value rounded up to next alignment.</returns>
      <remarks>
            Will return incorrect results if <paramref name="multiple" /> is zero.
            </remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.CountBitsSetI32(System.Int32)">
      <summary>
            This method counts how many bits are set in a given value.
            </summary>
      <param name="value">The value to count bits set.</param>
      <returns>How many bits are set in a given value.</returns>
      <remarks>
            This algorithm is from <see href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel" />.
            </remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.CountBitsSetU32(System.UInt32)">
      <summary>
            This method counts how many bits are set in a given value.
            </summary>
      <param name="value">The value to count bits set.</param>
      <returns>How many bits are set in a given value.</returns>
      <remarks>
            This algorithm is from <see href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel" />.
            </remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.CountBitsSetI64(System.Int64)">
      <summary>
            This method counts how many bits are set in a given value.
            </summary>
      <param name="value">The value to count bits set.</param>
      <returns>How many bits are set in a given value.</returns>
      <remarks>
            This algorithm is from <see href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel" />.
            </remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.CountBitsSetU64(System.UInt64)">
      <summary>
            This method counts how many bits are set in a given value.
            </summary>
      <param name="value">The value to count bits set.</param>
      <returns>How many bits are set in a given value.</returns>
      <remarks>
            This algorithm is from <see href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel" />.
            </remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.IsPowerOfTwo(System.UInt32)">
      <summary>
            Checks whether given unsigned integer is power of two.
            </summary>
      <param name="val">The integer to check.</param>
      <returns>
        <c>true</c> if the integer is power of two (and thus greater than zero); <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.IsPowerOfTwo(System.UInt64)">
      <summary>
            Checks whether given unsigned integer is power of two.
            </summary>
      <param name="val">The integer to check.</param>
      <returns>
        <c>true</c> if the integer is power of two (and thus greater than zero); <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.IsEven(System.UInt32)">
      <summary>
            Checks whehter given unsigned integer is even.
            Zero is considered to be even.
            </summary>
      <param name="val">The integer to check.</param>
      <returns>
        <c>true</c> if the integer is even; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.IsEven(System.UInt64)">
      <summary>
            Checks whehter given unsigned integer is even.
            Zero is considered to be even.
            </summary>
      <param name="val">The integer to check.</param>
      <returns>
        <c>true</c> if the integer is even; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.GetOrAdd_NotThreadSafe``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
      <summary>
            Gets or adds value from <paramref name="dictionary" /> given a <paramref name="key" />, using <paramref name="valueFactory" /> as value factory. Not threadsafe.
            </summary>
      <typeparam name="TKey">The type of the keys in <paramref name="dictionary" />.</typeparam>
      <typeparam name="TValue">The type of the values in <paramref name="dictionary" />.</typeparam>
      <param name="dictionary">The dictionary to get value from. If value does not exist for <paramref name="key" />, it will be added to dictionary.</param>
      <param name="key">The key to use to search value from <paramref name="dictionary" />.</param>
      <param name="valueFactory">The callback to generate value.</param>
      <returns>The value which was either found in <paramref name="dictionary" /> or created by <paramref name="valueFactory" />.</returns>
      <exception cref="T:System.ArgumentNullException">If value is not found from <paramref name="dictionary" /> using <paramref name="key" />, and <paramref name="valueFactory" /> is <c>null</c>.</exception>
      <exception cref="T:System.NullReferenceException">If <paramref name="dictionary" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.GetOrAdd_NotThreadSafe``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
      <summary>
            Gets or adds value from <paramref name="dictionary" /> given a <paramref name="key" />, using <paramref name="valueFactory" /> as value factory. Not threadsafe.
            </summary>
      <typeparam name="TKey">The type of the keys in <paramref name="dictionary" />.</typeparam>
      <typeparam name="TValue">The type of the values in <paramref name="dictionary" />.</typeparam>
      <param name="dictionary">The dictionary to get value from. If value does not exist for <paramref name="key" />, it will be added to dictionary.</param>
      <param name="key">The key to use to search value from <paramref name="dictionary" />.</param>
      <param name="valueFactory">The callback to generate value. The parameter will be <paramref name="key" />.</param>
      <returns>The value which was either found in <paramref name="dictionary" /> or created by <paramref name="valueFactory" />.</returns>
      <exception cref="T:System.ArgumentNullException">If value is not found from <paramref name="dictionary" /> using <paramref name="key" />, and <paramref name="valueFactory" /> is <c>null</c>.</exception>
      <exception cref="T:System.NullReferenceException">If <paramref name="dictionary" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.GetOrAdd_NotThreadSafe``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1},System.Boolean@)">
      <summary>
            Gets or adds value from <paramref name="dictionary" /> given a <paramref name="key" />, using <paramref name="valueFactory" /> as value factory. Not threadsafe.
            </summary>
      <typeparam name="TKey">The type of the keys in <paramref name="dictionary" />.</typeparam>
      <typeparam name="TValue">The type of the values in <paramref name="dictionary" />.</typeparam>
      <param name="dictionary">The dictionary to get value from. If value does not exist for <paramref name="key" />, it will be added to dictionary.</param>
      <param name="key">The key to use to search value from <paramref name="dictionary" />.</param>
      <param name="valueFactory">The callback to generate value. The parameter will be <paramref name="key" />.</param>
      <param name="added">This parameter will be <c>true</c> if this method added a new value to dictionary; <c>false</c> otherwise.</param>
      <returns>The value which was either found in <paramref name="dictionary" /> or created by <paramref name="valueFactory" />.</returns>
      <exception cref="T:System.ArgumentNullException">If value is not found from <paramref name="dictionary" /> using <paramref name="key" />, and <paramref name="valueFactory" /> is <c>null</c>.</exception>
      <exception cref="T:System.NullReferenceException">If <paramref name="dictionary" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.GetOrAdd_WithLock``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1},System.Boolean@,System.Object)">
      <summary>
            Gets or adds value from <paramref name="dictionary" /> given a <paramref name="key" />, using <paramref name="valueFactory" /> as value factory. Threadsafe - will lock given lock or whole dictionary when adding.
            </summary>
      <typeparam name="TKey">The type of the keys in <paramref name="dictionary" />.</typeparam>
      <typeparam name="TValue">The type of the values in <paramref name="dictionary" />.</typeparam>
      <param name="dictionary">The dictionary to get value from. If value does not exist for <paramref name="key" />, it will be added to dictionary.</param>
      <param name="key">The key to use to search value from <paramref name="dictionary" />.</param>
      <param name="valueFactory">The callback to generate value. The parameter will be <paramref name="key" />.</param>
      <param name="added">This parameter will be <c>true</c> if this method added a new value to dictionary; <c>false</c> otherwise.</param>
      <param name="lockToUse">The lock to use when the value does not exist. If not given (is <c>null</c>), the dictionary itself will be used as lock.</param>
      <returns>The value which was either found in <paramref name="dictionary" /> or created by <paramref name="valueFactory" />.</returns>
      <exception cref="T:System.ArgumentNullException">If value is not found from <paramref name="dictionary" /> using <paramref name="key" />, and <paramref name="valueFactory" /> is <c>null</c>.</exception>
      <exception cref="T:System.NullReferenceException">If <paramref name="dictionary" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.GetOrAdd_WithLock``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1},System.Object)">
      <summary>
            Gets or adds value from <paramref name="dictionary" /> given a <paramref name="key" />, using <paramref name="valueFactory" /> as value factory. Threadsafe - will lock given lock or whole dictionary when adding.
            </summary>
      <typeparam name="TKey">The type of the keys in <paramref name="dictionary" />.</typeparam>
      <typeparam name="TValue">The type of the values in <paramref name="dictionary" />.</typeparam>
      <param name="dictionary">The dictionary to get value from. If value does not exist for <paramref name="key" />, it will be added to dictionary.</param>
      <param name="key">The key to use to search value from <paramref name="dictionary" />.</param>
      <param name="valueFactory">The callback to generate value. The parameter will be <paramref name="key" />.</param>
      <param name="lockToUse">The lock to use when the value does not exist. If not given (is <c>null</c>), the dictionary itself will be used as lock.</param>
      <returns>The value which was either found in <paramref name="dictionary" /> or created by <paramref name="valueFactory" />.</returns>
      <exception cref="T:System.ArgumentNullException">If value is not found from <paramref name="dictionary" /> using <paramref name="key" />, and <paramref name="valueFactory" /> is <c>null</c>.</exception>
      <exception cref="T:System.NullReferenceException">If <paramref name="dictionary" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.GetOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
      <summary>
            Tries to get value from <paramref name="dic" /> using <paramref name="key" />, or return <paramref name="defaultValue" /> if no value is associated for <paramref name="key" /> in <paramref name="dic" />.
            </summary>
      <typeparam name="TKey">The type of the keys in <paramref name="dic" />.</typeparam>
      <typeparam name="TValue">The type of the values in <paramref name="dic" />.</typeparam>
      <param name="dic">The dictionary to search value from. If value does not exist for <paramref name="key" />, it will not be added to dictionary.</param>
      <param name="key">The key to use to search value from <paramref name="dic" />.</param>
      <param name="defaultValue">The value to return if no value exists for <paramref name="key" /> in <paramref name="dic" />.</param>
      <returns>The value for <paramref name="key" /> in <paramref name="dic" />, or <paramref name="defaultValue" /> if <paramref name="dic" /> does not have value associated for <paramref name="key" />.</returns>
      <exception cref="T:System.NullReferenceException">If <paramref name="dic" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.StructArrayEquals``1(``0[],``0[])">
      <summary>
            Checks whether two struct arrays are both <c>null</c> or both non-<c>null</c> and they contain the same sequence of elements.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="array1">The first array.</param>
      <param name="array2">The second array.</param>
      <returns>
        <c>true</c> if both arrays are <c>null</c> or if both arrays are non-<c>null</c> and contain the same sequence of elements; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.Swap``1(``0[],System.Int32,System.Int32)">
      <summary>
            Helper method to swap two elements in the array.
            </summary>
      <typeparam name="T">The type of the elements in the array.</typeparam>
      <param name="array">The array.</param>
      <param name="idx1">The index of one element to swap.</param>
      <param name="idx2">The index of another element to swap.</param>
      <exception cref="T:System.NullReferenceException">If <paramref name="array" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="idx1" /> or <paramref name="idx2" /> are out of index range for the array.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.BinarySearchDeferredEqualityDetection``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            Uses deferred equality detection version of binary search to find suitable item from given array.
            This means that if the elements are not unique, it returns the smallest index of the region where element is considered to match the given item.
            </summary>
      <typeparam name="T">The type of the elements in the array.</typeparam>
      <param name="array">The array.</param>
      <param name="item">The item to search.</param>
      <param name="comparer">The comparer to use. If <c>null</c>, a default comparer will be used.</param>
      <returns>The index of the first element matching the given <paramref name="item" />, or <c>-1</c> if no such element found or if <paramref name="array" /> is <c>null</c>.</returns>
      <remarks>
            As normal binary search algorithm, this assumes that the array is sorted based on the given comparer.
            Wrong result will be produced if the array is not sorted.
            </remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.BinarySearchDeferredEqualityDetection``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            Uses deferred equality detection version of binary search to find suitable item from given list.
            This means that if the elements are not unique, it returns the smallest index of the region where element is considered to match the given item.
            </summary>
      <typeparam name="T">The type of the elements in the list.</typeparam>
      <param name="list">The array.</param>
      <param name="item">The item to search.</param>
      <param name="comparer">The comparer to use. If <c>null</c>, a default comparer will be used.</param>
      <returns>The index of the first element matching the given <paramref name="item" />, or <c>-1</c> if no such element found or if <paramref name="list" /> is <c>null</c>.</returns>
      <remarks>
            As normal binary search algorithm, this assumes that the list is sorted based on the given comparer.
            Wrong result will be produced if the list is not sorted.
            </remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.IsNullOrEmpty``1(``0[])">
      <summary>
            Checks whether the array is <c>null</c> or an empty array.
            </summary>
      <typeparam name="T">The array element type.</typeparam>
      <param name="array">The array.</param>
      <returns>
        <c>true</c> if <paramref name="array" /> is not <c>null</c> and contains at least one element; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Checks whether the enumerable is <c>null</c> or an empty enumerable.
            </summary>
      <typeparam name="T">The enumerable element type.</typeparam>
      <param name="enumerable">The enumerable.</param>
      <returns>
        <c>true</c> if <paramref name="enumerable" /> is not <c>null</c> and contains at least one element; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.GetLengthOrDefault``1(``0[],System.Int32)">
      <summary>
            Gets the length of the array, or returns default length, if array is <c>null</c>.
            </summary>
      <typeparam name="T">The array element type.</typeparam>
      <param name="array">The array.</param>
      <param name="nullLength">The length to return if <paramref name="array" /> is <c>null</c>.</param>
      <returns>The length of the <paramref name="array" /> or <paramref name="nullLength" /> if <paramref name="array" /> is <c>null</c>.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.GetElementOrDefault``1(``0[],System.Int32,``0)">
      <summary>
            Gets the element at given index, or returns default if index is out of range.
            </summary>
      <typeparam name="T">The array element type.</typeparam>
      <param name="array">The array.</param>
      <param name="index">The index in the <paramref name="array" />.</param>
      <param name="defaultValue">The default value to return, if index is out of range.</param>
      <returns>The element at given index in given array, if index is valid; <paramref name="defaultValue" /> otherwise.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.GetElementOrDefault``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
      <summary>
            Gets the element at given index, or returns default if index is out of range.
            </summary>
      <typeparam name="T">The list element type.</typeparam>
      <param name="list">The list.</param>
      <param name="index">The index in the <paramref name="list" />.</param>
      <param name="defaultValue">The default value to return, if index is out of range.</param>
      <returns>The element at given index in given array, if index is valid; <paramref name="defaultValue" /> otherwise.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.EmptyOrAllEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Checks that the enumerable is either empty, or all of its values are considered to be same.
            </summary>
      <typeparam name="T">The enumerable element type.</typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="equalityComparer">The optional equality comparer to use when comparing values, default will be used if none is supplied.</param>
      <returns>
        <c>true</c> if <paramref name="enumerable" /> is empty or all of its values are considered to be the same; <c>false</c> otherwise.</returns>
      <remarks>
            This method will enumerable <paramref name="enumerable" /> exactly once, and has a <c>O(n)</c> performance time.
            </remarks>
      <exception cref="T:System.NullReferenceException">If <paramref name="enumerable" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.EmptyOrAllEqual``1(System.Collections.Generic.IEnumerable{``0},``0@,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Checks that the enumerable is either empty, or all of its values are considered to be same.
            </summary>
      <typeparam name="T">The enumerable element type.</typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="first">This parameter will have the first value of the enumerable, if the enumerable is not empty. If this method returns <c>true</c>, and enumerable is not empty, then this can be considered as single value that enumerable consists of.</param>
      <param name="equalityComparer">The optional equality comparer to use when comparing values, default will be used if none is supplied.</param>
      <returns>
        <c>true</c> if <paramref name="enumerable" /> is empty or all of its values are considered to be the same; <c>false</c> otherwise.</returns>
      <remarks>
            This method will enumerable <paramref name="enumerable" /> exactly once, and has a <c>O(n)</c> performance time.
            </remarks>
      <exception cref="T:System.NullReferenceException">If <paramref name="enumerable" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.CheckArrayArguments``1(``0[],System.Int32,System.Int32)">
      <summary>
            Checks whether given array is not <c>null</c> and has at least <paramref name="count" /> elements starting at <paramref name="offset" />.
            </summary>
      <typeparam name="T">The array element type.</typeparam>
      <param name="array">The array.</param>
      <param name="offset">The offset in array.</param>
      <param name="count">The amount of elements array must have starting at <paramref name="offset" />.</param>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="offset" /> or <paramref name="count" /> is less than <c>0</c>, or if array length is smaller than <paramref name="offset" /><c>+</c><paramref name="count" />.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="offset" /> + <paramref name="count" /> is greater than array length.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.Singleton``1(``0)">
      <summary>
            Changes a single element into a enumerable containing only that element.
            </summary>
      <typeparam name="T">The type of the element.</typeparam>
      <param name="element">The element.</param>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing only <paramref name="element" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.FilterNulls``1(``0[])">
      <summary>
            Helper method to filter out <c>null</c> values from arrays.
            If the array itself is <c>null</c>, an empty array is returned.
            </summary>
      <typeparam name="T">The type of array elements.</typeparam>
      <param name="array">The array.</param>
      <returns>An array where no element is <c>null</c>.</returns>
      <remarks>This will always return different array than given one.</remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.EmptyIfNull``1(``0[])">
      <summary>
            Helper method to return empty array in case given array is <c>null</c>.
            </summary>
      <typeparam name="T">The type of array elements.</typeparam>
      <param name="array">The array.</param>
      <returns>Empty array if <paramref name="array" /> is <c>null</c>; the <paramref name="array" /> if it is not <c>null</c>.</returns>
      <remarks>This will return different array only if it is <c>null</c>.</remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.GetOrDefault``1(``0[],System.Int32)">
      <summary>
            Helper method to safely fetch an element from array, even if array is <c>null</c>.
            </summary>
      <typeparam name="T">The type of array elements.</typeparam>
      <param name="array">The array.</param>
      <param name="index">The index where to get element.</param>
      <returns>The element at given index in given array. If <paramref name="array" /> is <c>null</c>, or if <paramref name="index" /> is out of suitable range (negative or greater or equal to array length), this will return default value for <typeparamref name="T" />.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.EmptyIfNull``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Helper method to return empty enumerable in case given enumerable is <c>null</c>.
            </summary>
      <typeparam name="T">The type of enumerable elements.</typeparam>
      <param name="enumerable">The enumerable.</param>
      <returns>Empty enumerable if <paramref name="enumerable" /> is <c>null</c>; the <paramref name="enumerable" /> if it is not <c>null</c>.</returns>
      <remarks>
            This will return different enumerable only if it is <c>null</c>.
            </remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.Fill``1(``0[],``0[])">
      <summary>
            This is method to quickly fill array with values, utilizing the fact that <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> methods are very, very fast.
            </summary>
      <typeparam name="T">The type of array elements.</typeparam>
      <param name="destinationArray">The array to be filled with values.</param>
      <param name="value">The values to fill array with.</param>
      <returns>The <paramref name="destinationArray" /></returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="destinationArray" /> or <paramref name="value" /> are null.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="destinationArray" /> is not empty, and length of <paramref name="value" /> is greater than length of <paramref name="destinationArray" />.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.FillWithNulls``1(``0[])">
      <summary>
            This is helper method to fill some class-based array with <c>null</c>s.
            Since the call <c>array.Fill(null)</c> will cause the actual array to be <c>null</c> instead of creating an array with <c>null</c> value.
            </summary>
      <typeparam name="T">The type of array elements.</typeparam>
      <param name="destinationArray">The array to be filled with values.</param>
      <returns>The <paramref name="destinationArray" /></returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.FillWithOffset``1(``0[],System.Int32,``0[])">
      <summary>
            This is method to quickly fill array with values, utilizing the fact that <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> methods are very, very fast.
            </summary>
      <typeparam name="T">The type of array elements.</typeparam>
      <param name="destinationArray">The array to be filled with values.</param>
      <param name="value">The values to fill array with.</param>
      <param name="offset">The offset at which to start filling array.</param>
      <returns>The <paramref name="destinationArray" /></returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="destinationArray" /> or <paramref name="value" /> are null.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="destinationArray" /> is not empty, and length of <paramref name="value" /> is greater than length of <paramref name="destinationArray" />.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.FillWithOffsetAndCount``1(``0[],System.Int32,System.Int32,``0[])">
      <summary>
            This is method to quickly fill array with values, utilizing the fact that <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> methods are very, very fast.
            </summary>
      <typeparam name="T">The type of array elements.</typeparam>
      <param name="destinationArray">The array to be filled with values.</param>
      <param name="value">The values to fill array with.</param>
      <param name="offset">The offset at which to start filling array.</param>
      <param name="count">How many items to fill.</param>
      <returns>The <paramref name="destinationArray" /></returns>
      <remarks>
            Original source code is found at <see href="http://stackoverflow.com/questions/5943850/fastest-way-to-fill-an-array-with-a-single-value" /> and <see href="http://coding.grax.com/2014/04/better-array-fill-function.html" />.
            According to first link, "<c>In my test with 20,000,000 array items, this function is twice as fast as a for loop.</c>".
            The source code was modified to fix a bug and also to support offset and count parameters.
            </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="destinationArray" /> or <paramref name="value" /> are null.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="destinationArray" /> is not empty, and length of <paramref name="value" /> is greater than length of <paramref name="destinationArray" />.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReverseFast``1(System.Collections.Generic.IList{``0})">
      <summary>
            This method will return a fast reversed enumerable of a given <see cref="T:System.Collections.Generic.IList`1" />, without the buffer overhead of <see cref="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" /> extension method.
            </summary>
      <typeparam name="T">The type of list elements.</typeparam>
      <param name="list">The <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <returns>Enumerable that will traverse the <paramref name="list" /> in reversed order, without using any buffers.</returns>
      <remarks>The resulting enumerable may break if one removes items between iterations.</remarks>
      <exception cref="T:System.NullReferenceException">If <paramref name="list" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.FirstOrDefaultCustom``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Acts like <see cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />, except the value which is returned when there are no elements can be customized.
            </summary>
      <typeparam name="T">The type of elements in the enumerable.</typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="defaultValue">The value to return when there are no elements in the enumerable.</param>
      <returns>The first element of the enumerable, or <paramref name="defaultValue" /> if there are no elements in the enumerable.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.EndOnFirstLoop``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            This extension method will make enumerable stop returning more items after it detects a loop in the sequence when enumerating.
            </summary>
      <typeparam name="T">The type of elements of <see cref="T:System.Collections.Generic.IEnumerable`1" />.</typeparam>
      <param name="enumerable">The <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
      <param name="equalityComparer">The equality comparer to use when detecting loops. If <c>null</c>, the default will be used.</param>
      <returns>Enumerable which will end when it detects a loop.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ArraysDeepEquals``1(``0[],``0[],UtilPack.Equality{``0})">
      <summary>
            Checks whether two arrays are of same size and they have the same elements.
            </summary>
      <typeparam name="T">The type of array elements.</typeparam>
      <param name="x">The first array.</param>
      <param name="y">The second array.</param>
      <param name="equality">The optional equality comparer for array elements.</param>
      <returns>
        <c>true</c> if <paramref name="x" /> and <paramref name="y" /> are of same size and have same elements; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ArraysDeepEqualUntyped(System.Array,System.Array,UtilPack.Equality{System.Object})">
      <summary>
            Method for checking whether two arrays are of same size and they have the same elements, when the type of array elements is unknown.
            </summary>
      <param name="x">The first array.</param>
      <param name="y">The second array.</param>
      <param name="equality">The optional equality callback for array elements.</param>
      <returns>
        <c>true</c> if <paramref name="x" /> and <paramref name="y" /> are of same size and have same elements; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.TryGetSingle``1(System.Collections.Generic.IEnumerable{``0},``0@)">
      <summary>
            Tries to get single value of an enumerable, if enumerable only has one element.
            </summary>
      <typeparam name="T">The type of elements of <see cref="T:System.Collections.Generic.IEnumerable`1" />.</typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="value">This will contain the single value of enumerable, if enumerable had only one element.</param>
      <returns>
        <c>true</c> if <paramref name="enumerable" /> was not <c>null</c> and had exactly one element; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},UtilPack.CollectionOverwriteStrategy,System.Collections.Generic.IEqualityComparer{``1},System.Func{System.Collections.Generic.IDictionary{``1,``2}})">
      <summary>
            Creates a dictionary from given enumerable, with customizable behaviour on how to handle duplicate keys, and optional callback to create the resulting dictionary.
            </summary>
      <typeparam name="T">The type of enumerable items.</typeparam>
      <typeparam name="TKey">The type of the keys in the resulting dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the resulting dictionary.</typeparam>
      <param name="source">The source enumerable.</param>
      <param name="keySelector">The callback to create keys from items of the enumerable.</param>
      <param name="valueSelector">The calllback to create values from items of the enumerable.</param>
      <param name="overwriteStrategy">The <see cref="T:UtilPack.CollectionOverwriteStrategy" /> on how to handle duplicate keys.</param>
      <param name="equalityComparer">The optional equality comparer for keys.</param>
      <param name="dictionaryFactory">The optional callback to create a new, empty dictionary.</param>
      <returns>A <see cref="T:System.Collections.Generic.IDictionary`2" /> containing transformed enumerable.</returns>
      <exception cref="T:System.ArgumentNullException">If any of <paramref name="source" />, <paramref name="keySelector" />, or <paramref name="valueSelector" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="overwriteStrategy" /> is <see cref="F:UtilPack.CollectionOverwriteStrategy.Throw" /> and there are duplicate keys during transformation.</exception>
      <exception cref="T:System.InvalidOperationException">If <paramref name="overwriteStrategy" /> is other than values in <see cref="T:UtilPack.CollectionOverwriteStrategy" /> enumeration.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ToDictionary_Overwrite``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1},System.Func{System.Collections.Generic.IEqualityComparer{``1},System.Collections.Generic.IDictionary{``1,``2}})">
      <summary>
            Creates a dictionary from given enumerable overwriting old values in case of duplicate keys, with optional callback to create the resulting dictionary.
            </summary>
      <typeparam name="T">The type of enumerable items.</typeparam>
      <typeparam name="TKey">The type of the keys in the resulting dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the resulting dictionary.</typeparam>
      <param name="source">The source enumerable.</param>
      <param name="keySelector">The callback to create keys from items of the enumerable.</param>
      <param name="valueSelector">The callback to create values from items of the enumerable.</param>
      <param name="equalityComparer">The optional equalit ycomparer for keys.</param>
      <param name="dictionaryFactory">The optional callback to create a new, empty dctionary.</param>
      <returns>A <see cref="T:System.Collections.Generic.IDictionary`2" /> containing transformed enumerable.</returns>
      <exception cref="T:System.ArgumentNullException">If any of <paramref name="source" />, <paramref name="keySelector" />, or <paramref name="valueSelector" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ToDictionary_Preserve``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1},System.Func{System.Collections.Generic.IEqualityComparer{``1},System.Collections.Generic.IDictionary{``1,``2}})">
      <summary>
            Creates a dictionary from given enumerable preserving old values in case of duplicate keys, with optional callback to create the resulting dictionary.
            </summary>
      <typeparam name="T">The type of enumerable items.</typeparam>
      <typeparam name="TKey">The type of the keys in the resulting dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the resulting dictionary.</typeparam>
      <param name="source">The source enumerable.</param>
      <param name="keySelector">The callback to create keys from items of the enumerable.</param>
      <param name="valueSelector">The callback to create values from items of the enumerable.</param>
      <param name="equalityComparer">The optional equalit ycomparer for keys.</param>
      <param name="dictionaryFactory">The optional callback to create a new, empty dctionary.</param>
      <returns>A <see cref="T:System.Collections.Generic.IDictionary`2" /> containing transformed enumerable.</returns>
      <exception cref="T:System.ArgumentNullException">If any of <paramref name="source" />, <paramref name="keySelector" />, or <paramref name="valueSelector" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ToDictionary_Throw``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1},System.Func{System.Collections.Generic.IEqualityComparer{``1},System.Collections.Generic.IDictionary{``1,``2}})">
      <summary>
            Creates a dictionary from given enumerable throwing an <see cref="T:System.ArgumentException" /> in case of duplicate keys, with optional callback to create the resulting dictionary.
            </summary>
      <typeparam name="T">The type of enumerable items.</typeparam>
      <typeparam name="TKey">The type of the keys in the resulting dictionary.</typeparam>
      <typeparam name="TValue">The type of the values in the resulting dictionary.</typeparam>
      <param name="source">The source enumerable.</param>
      <param name="keySelector">The callback to create keys from items of the enumerable.</param>
      <param name="valueSelector">The callback to create values from items of the enumerable.</param>
      <param name="equalityComparer">The optional equalit ycomparer for keys.</param>
      <param name="dictionaryFactory">The optional callback to create a new, empty dctionary.</param>
      <returns>A <see cref="T:System.Collections.Generic.IDictionary`2" /> containing transformed enumerable.</returns>
      <exception cref="T:System.ArgumentNullException">If any of <paramref name="source" />, <paramref name="keySelector" />, or <paramref name="valueSelector" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If there are duplicate keys during transformation.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ToArray_SelfIndexing``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32},UtilPack.CollectionOverwriteStrategy,System.Func{System.Int32,``0[]},System.Action{``0})">
      <summary>
            Creates an array out of the enumerable, where each item knows its own index in the array to be created.
            </summary>
      <typeparam name="T">The type of elements.</typeparam>
      <param name="source">The source enumerable.</param>
      <param name="indexExtractor">The callback to extract index from element.</param>
      <param name="overwriteStrategy">The <see cref="T:UtilPack.CollectionOverwriteStrategy" /> which will tell how to behave when two or more elements will be assigned the same array index.</param>
      <param name="arrayFactory">The optional array creation and resize callback.</param>
      <param name="settingFailed">The optional callback to invoke when setting item to array was not possible (e.g. array creation callback returned <c>null</c>).</param>
      <returns>The created array.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="source" /> or <paramref name="indexExtractor" /> are <c>null</c>.</exception>
      <exception cref="T:System.InvalidOperationException">If <paramref name="overwriteStrategy" /> is <see cref="F:UtilPack.CollectionOverwriteStrategy.Throw" />, and two elements will get assigned the same array index.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="overwriteStrategy" /> is other than values in <see cref="T:UtilPack.CollectionOverwriteStrategy" /> enumeration.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ToArray_SelfIndexing_Overwrite``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32},System.Func{System.Int32,``0[]},System.Action{``0})">
      <summary>
            Creates an array out of the enumerable, where each item knows its own index in the array to be created.
            When two or more elements will get assigned the same array index, the newest element will always overwrite the previous element.
            </summary>
      <typeparam name="T">The type of elements.</typeparam>
      <param name="source">The source enumerable.</param>
      <param name="indexExtractor">The callback to extract index from element.</param>
      <param name="arrayFactory">The optional array creation and resize callback.</param>
      <param name="settingFailed">The optional callback to invoke when setting item to array was not possible (e.g. array creation callback returned <c>null</c>).</param>
      <returns>The created array.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="source" /> or <paramref name="indexExtractor" /> are <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ToArray_SelfIndexing_Preserve``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32},System.Func{System.Int32,``0[]},System.Action{``0})">
      <summary>
            Creates an array out of the enumerable, where each item knows its own index in the array to be created.
            When two or more elements will get assigned the same array index, the newest element will always be discarded.
            </summary>
      <typeparam name="T">The type of elements.</typeparam>
      <param name="source">The source enumerable.</param>
      <param name="indexExtractor">The callback to extract index from element.</param>
      <param name="arrayFactory">The optional array creation and resize callback.</param>
      <param name="settingFailed">The optional callback to invoke when setting item to array was not possible (e.g. array creation callback returned <c>null</c>).</param>
      <returns>The created array.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="source" /> or <paramref name="indexExtractor" /> are <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ToArray_SelfIndexing_Throw``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32},System.Func{System.Int32,``0[]},System.Action{``0})">
      <summary>
            Creates an array out of the enumerable, where each item knows its own index in the array to be created.
            When two or more elements will get assigned the same array index, an exception will be thrown.
            </summary>
      <typeparam name="T">The type of elements.</typeparam>
      <param name="source">The source enumerable.</param>
      <param name="indexExtractor">The callback to extract index from element.</param>
      <param name="arrayFactory">The optional array creation and resize callback.</param>
      <param name="settingFailed">The optional callback to invoke when setting item to array was not possible (e.g. array creation callback returned <c>null</c>).</param>
      <returns>The created array.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="source" /> or <paramref name="indexExtractor" /> are <c>null</c>.</exception>
      <exception cref="T:System.InvalidOperationException">If two elements will get assigned the same array index.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.Shuffle``1(``0[],System.Random)">
      <summary>
            This method will shuffle the given array using <see href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates algorithm</see>.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="array">The array.</param>
      <param name="random">The optional <see cref="T:System.Random" /> to use for shuffle.</param>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.CreateArrayCopy``1(``0[])">
      <summary>
            Creates a copy of array.
            This is ease-of-life method for calling <see cref="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="array">The array.</param>
      <returns>The copy of the array, or <c>null</c>, if <paramref name="array" /> is <c>null</c>.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.CreateArrayCopy``1(``0[],System.Int32)">
      <summary>
            Creates a copy of section of given array, starting at given offset, and copying the rest of the array.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="array">The array.</param>
      <param name="count">The amount of elements to copy.</param>
      <returns>The newly created array, containing same elements as section of the given array.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.CreateArrayCopy``1(``0[],System.Int32,System.Int32)">
      <summary>
            Creates a copy of section of given array, starting at given offset and copying given amount of elements.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="array">The array.</param>
      <param name="offset">The offset in <paramref name="array" /> where to start copying elements.</param>
      <param name="count">The amount of elements to copy.</param>
      <returns>The newly created array, containing same elements as section of the given array.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.CopyTo``1(``0[],``0[])">
      <summary>
            This is helper method to <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> call with last parameter being the source array length.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="array">The source array. All elements will be copied.</param>
      <param name="targetArray">The target array. The first element will be copied to index <c>0</c>.</param>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.CopyTo``1(``0[],``0[],System.Int32@)">
      <summary>
            This is helper method to <see cref="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" /> call with bound parameters for target array index and element copy count.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="array">The source array. All elements remaining starting from <paramref name="sourceIndex" /> will be copied.</param>
      <param name="targetArray">The target element. The first element will be copied to index <c>0</c>.</param>
      <param name="sourceIndex">The index in source <paramref name="array" /> where to start copying.</param>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.CopyTo``1(``0[],``0[],System.Int32@,System.Int32,System.Int32)">
      <summary>
            This is pass-thru method to <see cref="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />, designed to make it easy to invoke it.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
      <param name="array">The source array.</param>
      <param name="targetArray">The target array.</param>
      <param name="sourceIndex">The index in source <paramref name="array" /> where to start copying.</param>
      <param name="targetIndex">The index in target <paramref name="targetArray" /> where to start copying.</param>
      <param name="count">The amount of elements to copy.</param>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.AggregateIntermediate_AfterAggregation``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})">
      <summary>
            Applices aggregation function over a sequence, but instead of returning the result of whole iteration, returns enumerable of intermediate results.
            Each result is returned after aggregator function is applied.
            </summary>
      <typeparam name="T">The type of enumerable items.</typeparam>
      <typeparam name="TAccumulate">The type of accumulation value.</typeparam>
      <param name="enumerable">The <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
      <param name="seed">The initial value to start accumulation.</param>
      <param name="aggregator">The aggregator function. First parameter is current accumulated value, second is current item.</param>
      <returns>Enumerable of intermediate results of aggregation over the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="aggregator" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.AggregateIntermediate_BeforeAggregation``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})">
      <summary>
            Applices aggregation function over a sequence, but instead of returning the result of whole iteration, returns enumerable of intermediate results.
            Each result is returned before aggregator function is applied.
            </summary>
      <typeparam name="T">The type of enumerable items.</typeparam>
      <typeparam name="TAccumulate">The type of accumulation value.</typeparam>
      <param name="enumerable">The <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
      <param name="seed">The initial value to start accumulation.</param>
      <param name="aggregator">The aggregator function. First parameter is current accumulated value, second is current item.</param>
      <returns>Enumerable of intermediate results of aggregation over the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="aggregator" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.AggregateIntermediate_AfterAggregation``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,System.Int32,``1})">
      <summary>
            Applices aggregation function over a sequence, but instead of returning the result of whole iteration, returns enumerable of intermediate results.
            Each result is returned after aggregator function is applied.
            </summary>
      <typeparam name="T">The type of enumerable items.</typeparam>
      <typeparam name="TAccumulate">The type of accumulation value.</typeparam>
      <param name="enumerable">The <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
      <param name="seed">The initial value to start accumulation.</param>
      <param name="aggregator">The aggregator function. First parameter is current accumulated value, second is current item, and third is current enumerable index.</param>
      <returns>Enumerable of intermediate results of aggregation over the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="aggregator" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.AggregateIntermediate_BeforeAggregation``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,System.Int32,``1})">
      <summary>
            Applices aggregation function over a sequence, but instead of returning the result of whole iteration, returns enumerable of intermediate results.
            Each result is returned before aggregator function is applied.
            </summary>
      <typeparam name="T">The type of enumerable items.</typeparam>
      <typeparam name="TAccumulate">The type of accumulation value.</typeparam>
      <param name="enumerable">The <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
      <param name="seed">The initial value to start accumulation.</param>
      <param name="aggregator">The aggregator function. First parameter is current accumulated value, second is current item, and third is current enumerable index.</param>
      <returns>Enumerable of intermediate results of aggregation over the sequence.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="aggregator" /> or <paramref name="enumerable" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.RememberPreviousItems``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean)">
      <summary>
            Returns an enumerable, which remembers given amount of previous items, in reversed order as they are encountered in enumerable.
            </summary>
      <typeparam name="T">The type of items of enumerable.</typeparam>
      <param name="enumerable">The <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
      <param name="maxAmountOfItemsToRemember">Maximum amount of previous items to remember.</param>
      <param name="firstResultShouldAlwaysHaveMaxAmount">Whether the first <see cref="T:UtilPack.PreviousItemsInfo`1" /> in the resulting enumerable should have <paramref name="maxAmountOfItemsToRemember" /> items. By default, this is <c>true</c>.</param>
      <returns>The enumerable of <see cref="T:UtilPack.PreviousItemsInfo`1" />s.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="enumerable" /> is <c>null</c>.</exception>
      <remarks>
            Please note that <see cref="P:UtilPack.PreviousItemsInfo`1.PreviousItems" /> enumerable has meaningful values only during enumeration the resulting enumerable of <see cref="T:UtilPack.PreviousItemsInfo`1" />s.
            So for example, if one does <see cref="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})" /> to a enumerable of <see cref="T:UtilPack.PreviousItemsInfo`1" /> and then tries to access the <see cref="P:UtilPack.PreviousItemsInfo`1.PreviousItems" />, the result will always be the same for every <see cref="T:UtilPack.PreviousItemsInfo`1" />.
            During enumeration of <see cref="T:UtilPack.PreviousItemsInfo`1" />s, the <see cref="P:UtilPack.PreviousItemsInfo`1.PreviousItems" /> will return correct values.
            </remarks>
      <seealso cref="T:UtilPack.PreviousItemsInfo`1" />
    </member>
    <member name="M:UtilPack.UtilPackExtensions.Append``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Returns enumerable which will return all items in this enumerable, and then concatenate a single item at the end.
            </summary>
      <typeparam name="T">The type of elements in <see cref="T:System.Collections.Generic.IEnumerable`1" />.</typeparam>
      <param name="enumerable">The <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
      <param name="singleItem">The single item.</param>
      <returns>Enumerable which will enumerate this enumerable, and then concatenate a single item at the end.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Returns enumerable which will first return given single item, and then all items in this enumerable.
            </summary>
      <typeparam name="T">The type of elements in <see cref="T:System.Collections.Generic.IEnumerable`1" />.</typeparam>
      <param name="enumerable">The <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
      <param name="singleItem">The single item.</param>
      <returns>Enumerable which will first return given single item, and then all items in this enumerable.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
      <summary>
            This method behaves the same way as <see cref="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />, but the predicate callback also accepts index parameter.
            </summary>
      <typeparam name="T">The type of enumerable items.</typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="predicate">The callback to execute.</param>
      <returns>
        <c>true</c> if <paramref name="enumerable" /> is empty or if given <paramref name="predicate" /> returns <c>true</c> for all its items; <c>false</c> otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">If either of <paramref name="enumerable" /> or <paramref name="predicate" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.AsCharEnumerable(System.Int64)">
      <summary>
            Gets given integer as enumerable of characters.
            </summary>
      <param name="i64">This integer.</param>
      <returns>Enumerable of characters that are textual representation of this integer.</returns>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.AsCharEnumerable(System.String)">
      <summary>
            Helper method to return string as enumerable of characters.
            </summary>
      <param name="str">This <see cref="T:System.String" />. May be <c>null</c>, then empty enumerable is returned.</param>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.ReadAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
      <todo />
    </member>
    <member name="M:UtilPack.UtilPackExtensions.WriteAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
      <todo />
    </member>
    <member name="M:UtilPack.UtilPackExtensions.FlushAsync(System.IO.Stream,System.Threading.CancellationToken)">
      <todo />
    </member>
    <member name="M:UtilPack.UtilPackExtensions.CreateDefaultEncodingInfo(System.Text.Encoding)">
      <summary>
            Creates the default encoding information for given <see cref="T:System.Text.Encoding" />.
            </summary>
      <param name="encoding">This <see cref="T:System.Text.Encoding" />.</param>
      <returns>A new instance of <see cref="T:UtilPack.IEncodingInfo" />.</returns>
      <exception cref="T:System.InvalidOperationException">If this method could not automatically deduct which <see cref="T:UtilPack.IEncodingInfo" /> to create.</exception>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.AsDepthFirstEnumerable``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Boolean)">
      <summary>
            Using a starting node and function to get children, returns enumerable which walks transitively through all nodes accessible from the starting node, in depth-first order.
            Does not check for loops, so if there are loops, this method will never return, until most likely <see cref="T:System.OutOfMemoryException" /> is thrown.
            </summary>
      <typeparam name="T">The type of the node</typeparam>
      <param name="head">Starting node</param>
      <param name="childrenFunc">Function to return children given a single node</param>
      <param name="returnHead">Whether to return <paramref name="head" /> as first element of resulting enumerable.</param>
      <returns>Enumerable to walk through all nodes accessible from start node, in depth-first order</returns>
      <remarks>This is not recursive algorithm.</remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.AsDepthFirstEnumerableWithLoopDetection``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Boolean,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Using a starting node and function to get children, returns enumerable which walks transitively through all nodes accessible from the starting node, in depth-first order.
            This algorithm checks for loops, so each reachable node is visited exactly once.
            </summary>
      <typeparam name="T">The type of the node</typeparam>
      <param name="head">Starting node</param>
      <param name="childrenFunc">Function to return children given a single node</param>
      <param name="returnHead">Whether to return <paramref name="head" /> as first element of resulting enumerable.</param>
      <param name="equalityComparer">The equality comparer to use when checking for loops. Can be <c>null</c> for default equality comparer.</param>
      <returns>Enumerable to walk through all nodes accessible from start node, in depth-first order.</returns>
      <remarks>This is not recursive algorithm.</remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.AsBreadthFirstEnumerable``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Boolean)">
      <summary>
            Using a starting node and function to get children, returns enumerable which walks transitively through all nodes accessible from the starting node, in breadth-first order.
            Does not check for loops, so if there are loops, this method will never return, until most likely <see cref="T:System.OutOfMemoryException" /> is thrown.
            </summary>
      <typeparam name="T">The type of the node</typeparam>
      <param name="head">Starting node</param>
      <param name="childrenFunc">Function to return children given a single node</param>
      <param name="returnHead">Whether to return <paramref name="head" /> as first element of resulting enumerable.</param>
      <returns>Enumerable to walk through all nodes accessible from start node, in breadth-first order</returns>
      <remarks>This is not a recursive algorithm.</remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.AsBreadthFirstEnumerableWithLoopDetection``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Boolean,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Using a starting node and function to get children, returns enumerable which walks transitively through all nodes accessible from the starting node, in breadth-first order.
            This algorithm checks for loops, so each reachable node is visited exactly once.
            </summary>
      <typeparam name="T">The type of the node</typeparam>
      <param name="head">Starting node</param>
      <param name="childrenFunc">Function to return children given a single node</param>
      <param name="returnHead">Whether to return <paramref name="head" /> as first element of resulting enumerable.</param>
      <param name="equalityComparer">The equality comparer to use when checking for loops. Can be <c>null</c> for default equality comparer.</param>
      <returns>Enumerable to walk through all nodes accessible from start node, in breadth-first order</returns>
      <remarks>This is not a recursive algorithm.</remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.AsSingleBranchEnumerable``1(``0,System.Func{``0,``0},System.Func{``0,System.Boolean},System.Boolean)">
      <summary>
            Using a starting node and function get child, returns enumerable which walks transitively through all nodes accessible from the starting node.
            Does not check for loops, so if there are loops, this method will never return, until most likely <see cref="T:System.OutOfMemoryException" /> is thrown.
            </summary>
      <typeparam name="T">The type of the node.</typeparam>
      <param name="head">Starting node.</param>
      <param name="childFunc">Function to return child given a single node.</param>
      <param name="endCondition">Customizable condition to end enumeration. By default it will end when the child returned by <paramref name="childFunc" /> will be <c>default(T)</c></param>
      <param name="includeFirst">Whether to include <paramref name="head" /> in the result. Note that if this is <c>false</c>, the <paramref name="childFunc" /> will be invoked on the <paramref name="head" /> without checking the end-condition.</param>
      <returns>Enumerable to walk through all nodes accessible from the start node.</returns>
      <remarks>This is not a recursive algorithm.</remarks>
    </member>
    <member name="M:UtilPack.UtilPackExtensions.AsSingleBranchEnumerableWithLoopDetection``1(``0,System.Func{``0,``0},System.Func{``0,System.Boolean},System.Boolean,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Using a starting node and function get child, returns enumerable which walks transitively through all nodes accessible from the starting node.
            This algorithm checks for loops, so each reachable node is visited exactly once.
            </summary>
      <typeparam name="T">The type of the node.</typeparam>
      <param name="head">Starting node.</param>
      <param name="childFunc">Function to return child given a single node.</param>
      <param name="endCondition">Customizable condition to end enumeration. By default it will end when the child returned by <paramref name="childFunc" /> will be <c>default(T)</c></param>
      <param name="includeFirst">Whether to include <paramref name="head" /> in the result. Note that if this is <c>false</c>, the <paramref name="childFunc" /> will be invoked on the <paramref name="head" /> without checking the end-condition.</param>
      <param name="equalityComparer">The equality comparer to use when checking for loops. Can be <c>null</c> for default equality comparer.</param>
      <returns>Enumerable to walk through all nodes accessible from the start node.</returns>
      <remarks>This is not a recursive algorithm.</remarks>
    </member>
    <member name="T:UtilPack.BinaryUtils">
      <summary>
            This class provides utility methods related to binary operations, which are not sensible to create as extension methods.
            </summary>
    </member>
    <member name="M:UtilPack.BinaryUtils.Log2(System.UInt32)">
      <summary>
            Returns the log base 2 of a given <paramref name="value" />.
            </summary>
      <param name="value">The value.</param>
      <returns>Log base 2 of <paramref name="value" />.</returns>
      <remarks>
            The return value is also the position of the MSB set, with zero-based indexing.
            The algorithm is from <see href="http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogLookup" /> .
            </remarks>
    </member>
    <member name="M:UtilPack.BinaryUtils.AmountOfPagesTaken(System.Int32,System.Int32)">
      <summary>
            Given amount of data and page size, calculates amount of pages the data will take.
            </summary>
      <param name="totalSize">The total size of the data.</param>
      <param name="pageSize">The size of a single page.</param>
      <returns>The amount of pages the data will take.</returns>
      <remarks>
            More specifically, this method will return <c>( <paramref name="totalSize" /> + <paramref name="pageSize" /> - 1 ) / <paramref name="pageSize" /></c></remarks>
    </member>
    <member name="M:UtilPack.BinaryUtils.Log2(System.UInt64)">
      <summary>
            Returns the log base 2 of a given <paramref name="value" />.
            </summary>
      <param name="value">The value.</param>
      <returns>Log base 2 of <paramref name="value" />.</returns>
      <remarks>
            The return value is also the position of the MSB set, with zero-based indexing.
            The algorithm uses <see cref="M:UtilPack.BinaryUtils.Log2(System.UInt32)" /> method to calculate return value.
            </remarks>
    </member>
    <member name="M:UtilPack.BinaryUtils.GCD(System.Int32,System.Int32)">
      <summary>
            Computes greatest common denominator without recursion.
            </summary>
      <param name="x">The first number.</param>
      <param name="y">The second number.</param>
      <returns>The greatest common denominator of <paramref name="x" /> and <paramref name="y" />.</returns>
    </member>
    <member name="M:UtilPack.BinaryUtils.GCD64(System.Int64,System.Int64)">
      <summary>
            Computes greatest common denominator without recursion, for <see cref="T:System.Int64" />.
            </summary>
      <param name="x">The first number.</param>
      <param name="y">The second number.</param>
      <returns>The greatest common denominator of <paramref name="x" /> and <paramref name="y" />.</returns>
    </member>
    <member name="M:UtilPack.BinaryUtils.LCM(System.Int32,System.Int32)">
      <summary>
            Computes least common multiplier (by using greatest common denominator).
            </summary>
      <param name="x">The first number.</param>
      <param name="y">The second number.</param>
      <returns>The least common multiplier of <paramref name="x" /> and <paramref name="y" />.</returns>
    </member>
    <member name="M:UtilPack.BinaryUtils.LCM64(System.Int64,System.Int64)">
      <summary>
            Computes least common multiplier (by using greatest common denominator), for <see cref="T:System.Int64" />.
            </summary>
      <param name="x">The first number.</param>
      <param name="y">The second number.</param>
      <returns>The least common multiplier of <paramref name="x" /> and <paramref name="y" />.</returns>
    </member>
    <member name="M:UtilPack.BinaryUtils.FLP2(System.UInt32)">
      <summary>
            Returns greatest power of 2 less than or equal to given number.
            </summary>
      <param name="x">The number.</param>
      <returns>The greatest power of 2 less than or equal to <paramref name="x" />.</returns>
    </member>
    <member name="M:UtilPack.BinaryUtils.FLP264(System.UInt64)">
      <summary>
            Returns greatest power of 2 less than or equal to given 64-bit number.
            </summary>
      <param name="x">The number.</param>
      <returns>The greatest power of 2 less than or equal to <paramref name="x" />.</returns>
    </member>
    <member name="M:UtilPack.BinaryUtils.CLP2(System.UInt32)">
      <summary>
            Returns least power of 2 greater than or equal to given number.
            </summary>
      <param name="x">The number.</param>
      <returns>The least power of 2 greater than or equal to <paramref name="x" />.</returns>
    </member>
    <member name="M:UtilPack.BinaryUtils.CLP264(System.UInt64)">
      <summary>
            Returns least power of 2 greater than or equal to given 64-bit number.
            </summary>
      <param name="x">The number.</param>
      <returns>The least power of 2 greater than or equal to <paramref name="x" />.</returns>
    </member>
    <member name="M:UtilPack.BinaryUtils.Calculate7BitEncodingLength(System.Int32)">
      <summary>
            Calculates the amount of bytes needed when encoding the given integer value using 7-bit encoding.
            </summary>
      <param name="value">The integer value.</param>
      <returns>The amount of bytes needed to encode <paramref name="value" /> using 7-bit encoding.</returns>
      <seealso cref="M:UtilPack.UtilPackExtensions.WriteInt32LEEncoded7Bit(System.Byte[],System.Int32@,System.Int32)" />
      <seealso cref="M:UtilPack.UtilPackExtensions.WriteInt32BEEncoded7Bit(System.Byte[],System.Int32@,System.Int32)" />
      <seealso cref="M:UtilPack.UtilPackExtensions.ReadInt32LEEncoded7Bit(System.Byte[],System.Int32@,System.Boolean)" />
      <seealso cref="M:UtilPack.UtilPackExtensions.ReadInt32BEEncoded7Bit(System.Byte[],System.Int32@,System.Boolean)" />
    </member>
    <member name="M:UtilPack.BinaryUtils.Calculate7BitEncodingLength(System.Int64)">
      <summary>
            Calculates the amount of bytes needed when encoding the given integer value using 7-bit encoding.
            </summary>
      <param name="value">The integer value.</param>
      <returns>The amount of bytes needed to encode <paramref name="value" /> using 7-bit encoding.</returns>
      <seealso cref="M:UtilPack.UtilPackExtensions.WriteInt64LEEncoded7Bit(System.Byte[],System.Int32@,System.Int64)" />
      <seealso cref="M:UtilPack.UtilPackExtensions.WriteInt64BEEncoded7Bit(System.Byte[],System.Int32@,System.Int64)" />
      <seealso cref="M:UtilPack.UtilPackExtensions.ReadInt64LEEncoded7Bit(System.Byte[],System.Int32@,System.Boolean)" />
      <seealso cref="M:UtilPack.UtilPackExtensions.ReadInt64BEEncoded7Bit(System.Byte[],System.Int32@,System.Boolean)" />
    </member>
    <member name="T:UtilPack.CollectionOverwriteStrategy">
      <summary>
            This is enumeration to use when deciding how to handle duplicate key values in <see cref="M:UtilPack.UtilPackExtensions.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},UtilPack.CollectionOverwriteStrategy,System.Collections.Generic.IEqualityComparer{``1},System.Func{System.Collections.Generic.IDictionary{``1,``2}})" /> method.
            </summary>
    </member>
    <member name="F:UtilPack.CollectionOverwriteStrategy.Preserve">
      <summary>
            When a duplicate key is encountered, old value is preserved and new value is discarded.
            </summary>
    </member>
    <member name="F:UtilPack.CollectionOverwriteStrategy.Overwrite">
      <summary>
            When a duplicate key is encountered, old value is discarded and new value will replace the old value.
            </summary>
    </member>
    <member name="F:UtilPack.CollectionOverwriteStrategy.Throw">
      <summary>
            When a duplicate key is encountered, an <see cref="T:System.ArgumentException" /> is thrown.
            </summary>
    </member>
    <member name="T:UtilPack.PreviousItemsInfo`1">
      <summary>
            This type represents information about current item in <see cref="T:System.Collections.Generic.IEnumerable`1" /> and the previous items.
            </summary>
      <typeparam name="T">The type of items in <see cref="T:System.Collections.Generic.IEnumerable`1" />.</typeparam>
    </member>
    <member name="M:UtilPack.PreviousItemsInfo`1.#ctor(`0,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.PreviousItemsInfo`1" /> with given current and previous items.
            </summary>
      <param name="currentItem">The current item.</param>
      <param name="previousItems">The previous items. If <c>null</c>, then empty enumerable will be used.</param>
    </member>
    <member name="P:UtilPack.PreviousItemsInfo`1.CurrentItem">
      <summary>
            Gets the current item.
            </summary>
      <value>The current item.</value>
    </member>
    <member name="P:UtilPack.PreviousItemsInfo`1.PreviousItems">
      <summary>
            Gets the previous items.
            </summary>
      <value>The previous items.</value>
    </member>
    <member name="T:UtilPack.ComparerFromFunctions">
      <summary>
            Provides an easy way to create (equality) comparer based on lambdas.
            </summary>
    </member>
    <member name="M:UtilPack.ComparerFromFunctions.NewEqualityComparer``1(UtilPack.Equality{``0},UtilPack.HashCode{``0})">
      <summary>
            Creates a new <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> which behaves as <paramref name="equals" /> and <paramref name="hashCode" /> callbakcs specify.
            </summary>
      <typeparam name="T">The type of objects being compared for equality.</typeparam>
      <param name="equals">The function for comparing equality for <typeparamref name="T" />.</param>
      <param name="hashCode">The function for calculating hash code for <typeparamref name="T" />.</param>
      <returns>A new <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> which behaves as parameters specify.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="equals" /> or <paramref name="hashCode" /> is <c>null</c>.</exception>
      <remarks>The return value can be casted to <see cref="T:System.Collections.IEqualityComparer" />.</remarks>
    </member>
    <member name="M:UtilPack.ComparerFromFunctions.NewComparer``1(System.Comparison{``0})">
      <summary>
            Creates a new <see cref="T:System.Collections.Generic.IComparer`1" /> which behaves as <paramref name="comparison" /> callback specify.
            </summary>
      <typeparam name="T">The type of object being compared.</typeparam>
      <param name="comparison">The function comparing the object, should return same as <see cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)" /> method.</param>
      <returns>A new <see cref="T:System.Collections.Generic.IComparer`1" /> which behaves as parameters specify.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="comparison" /> is <c>null</c>.</exception>
      <remarks>The return value can be casted to <see cref="T:System.Collections.IComparer" />.</remarks>
    </member>
    <member name="M:UtilPack.ComparerFromFunctions.NewComparerWithNullStrategy``1(System.Comparison{``0},UtilPack.NullSorting)">
      <summary>
            Creates a new <see cref="T:System.Collections.Generic.IComparer`1" /> which behaves as <paramref name="comparison" /> callback specify, and which sorts <c>null</c> values according to given strategy.
            This means that the given callback will never receive <c>null</c> values.
            </summary>
      <typeparam name="T">The type of object being compared.</typeparam>
      <param name="comparison">The function comparing the object, should return same as <see cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)" /> method.</param>
      <param name="nullSortingStrategy">The strategy to sort <c>null</c> values.</param>
      <returns>A new <see cref="T:System.Collections.Generic.IComparer`1" /> which behaves as parameters specify.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="comparison" /> is <c>null</c>.</exception>
      <remarks>The return value can be casted to <see cref="T:System.Collections.IComparer" />.</remarks>
    </member>
    <member name="M:UtilPack.ComparerFromFunctions.GetDefaultItemComparerForSomeSequence``1">
      <summary>
            If <typeparamref name="T" /> is an array, then returns a <see cref="P:UtilPack.ArrayEqualityComparer`1.DefaultArrayEqualityComparer" /> for array element type.
            If <typeparamref name="T" /> is or implements <see cref="T:System.Collections.Generic.IList`1" /> exactly once, then returns a <see cref="P:UtilPack.ListEqualityComparer`2.DefaultListEqualityComparer" /> for list element type.
            If <typeparamref name="T" /> is or implements <see cref="T:System.Collections.Generic.ICollection`1" /> exactly once, then returns a <see cref="P:UtilPack.CollectionEqualityComparer`2.DefaultCollectionEqualityComparer" /> for collection element type.
            Otherwise returns <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.
            </summary>
      <typeparam name="T">The type of items in sequence.</typeparam>
      <returns>The default equality comparer for array element type, keeping an eye on the fact that <typeparamref name="T" /> may be an array, a list, or a collection.</returns>
      <remarks>
            Since <see cref="P:UtilPack.ArrayEqualityComparer`1.DefaultArrayEqualityComparer" />, <see cref="P:UtilPack.ListEqualityComparer`2.DefaultListEqualityComparer" />, and <see cref="P:UtilPack.CollectionEqualityComparer`2.DefaultCollectionEqualityComparer" /> all use this method, this will recursively travel all types.
            </remarks>
    </member>
    <member name="T:UtilPack.NullSorting">
      <summary>
            This is the enumeration for picking strategy for sorting null values.
            </summary>
    </member>
    <member name="F:UtilPack.NullSorting.NullsFirst">
      <summary>
            This tells to sort <c>null</c> values first.
            </summary>
    </member>
    <member name="F:UtilPack.NullSorting.NullsLast">
      <summary>
            This tells to sort <c>null</c> values last.
            </summary>
    </member>
    <member name="T:UtilPack.EqualityComparerWrapper`1">
      <summary>
            Helper class wrapping a generic <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, and implementing both generic <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> and non-generic <see cref="T:System.Collections.IEqualityComparer" />.
            </summary>
      <typeparam name="TValue">The type of the elements to compare.</typeparam>
    </member>
    <member name="M:UtilPack.EqualityComparerWrapper`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.EqualityComparerWrapper`1" /> with given comparer to delegate comparison to.
            </summary>
      <param name="comparer">The actual equality comparer.</param>
      <exception cref="T:System.ArgumentNullException">If <paramref name="comparer" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.EqualityComparerWrapper`1.Equals(`0,`0)">
      <summary>
            Delegates this call to the comparer given to <see cref="M:UtilPack.EqualityComparerWrapper`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />.
            </summary>
      <param name="x">The first value to compare.</param>
      <param name="y">The second value to compare.</param>
      <returns>The result of comparer given to <see cref="M:UtilPack.EqualityComparerWrapper`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />.</returns>
      <remarks>This method is virtual and is called by explicitly implemented method of <see cref="M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)" />.</remarks>
    </member>
    <member name="M:UtilPack.EqualityComparerWrapper`1.GetHashCode(`0)">
      <summary>
            Delegates this call to the comparer given to <see cref="M:UtilPack.EqualityComparerWrapper`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" /></summary>
      <param name="obj">The object to get hash code for.</param>
      <returns>The value of comparer given to <see cref="M:UtilPack.EqualityComparerWrapper`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />.</returns>
      <remarks>This method is virtual and is called by explicitly implemented method of <see cref="M:System.Collections.IEqualityComparer.GetHashCode(System.Object)" />.</remarks>
    </member>
    <member name="T:UtilPack.ComparerWrapper`1">
      <summary>
            Helper class wrapping a generic <see cref="T:System.Collections.Generic.IComparer`1" />, and implementing both generic <see cref="T:System.Collections.Generic.IComparer`1" /> and non-generic <see cref="T:System.Collections.IComparer" />.
            </summary>
      <typeparam name="TValue">The type of the elements to compare.</typeparam>
    </member>
    <member name="M:UtilPack.ComparerWrapper`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.ComparerWrapper`1" /> with given comparer to delegate comparison to.
            </summary>
      <param name="comparer">The actual comparer.</param>
      <exception cref="T:System.ArgumentNullException">If <paramref name="comparer" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.ComparerWrapper`1.Compare(`0,`0)">
      <summary>
            Delegates this call to the comparer given to <see cref="M:UtilPack.ComparerWrapper`1.#ctor(System.Collections.Generic.IComparer{`0})" /></summary>
      <param name="x">The first value to compare.</param>
      <param name="y">The second value to compare.</param>
      <returns>The result of comparer given to <see cref="M:UtilPack.ComparerWrapper`1.#ctor(System.Collections.Generic.IComparer{`0})" />.</returns>
      <remarks>This method is virtual and is called by explicitly implemented method of <see cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)" />.</remarks>
    </member>
    <member name="T:UtilPack.Empty`1">
      <summary>
            Helper class to provide easy access to cached empty array and <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
      <typeparam name="T">The type of array or enumerable elements.</typeparam>
    </member>
    <member name="P:UtilPack.Empty`1.Array">
      <summary>
            Returns instance of array with zero elements.
            </summary>
      <value>Instance of array with zero elements.</value>
    </member>
    <member name="P:UtilPack.Empty`1.Enumerable">
      <summary>
            Returns instance of <see cref="T:System.Collections.Generic.IEnumerable`1" /> with no elements.
            </summary>
      <value>Instance of <see cref="T:System.Collections.Generic.IEnumerable`1" /> with no elements.</value>
    </member>
    <member name="T:UtilPack.LocklessInstancePoolForClasses`1">
      <summary>
            This is common interface for classes providing instance pool functionality for types which are reference types.
            </summary>
      <typeparam name="TInstance"></typeparam>
    </member>
    <member name="M:UtilPack.LocklessInstancePoolForClasses`1.TakeInstance">
      <summary>
            Takes an existing instance from this pool and returns it, or returns <c>null</c> if no existing instance is available.
            </summary>
      <returns>An existing instance of <typeparamref name="TInstance" />, or <c>null</c> if no existing instance is available.</returns>
    </member>
    <member name="M:UtilPack.LocklessInstancePoolForClasses`1.ReturnInstance(`0)">
      <summary>
            Returns an existing instance to this pool. Nothing is done if <paramref name="instance" /> is <c>null</c>.
            </summary>
      <param name="instance">The instance to return to this pool.</param>
    </member>
    <member name="T:UtilPack.DefaultLocklessInstancePoolForClasses`1">
      <summary>
            This class implements semantics of containing multiple instances of some type, with methods for taking and returning instances.
            This class is fully threadsafe and does not use locks in its implementation.
            The type must be class or interface.
            </summary>
      <typeparam name="TInstance">The type of the instances to hold.</typeparam>
    </member>
    <member name="M:UtilPack.DefaultLocklessInstancePoolForClasses`1.#ctor">
      <summary>
            Creates new instance of <see cref="T:UtilPack.DefaultLocklessInstancePoolForClasses`1" />.
            </summary>
    </member>
    <member name="M:UtilPack.DefaultLocklessInstancePoolForClasses`1.TakeInstance">
      <inheritdoc />
    </member>
    <member name="M:UtilPack.DefaultLocklessInstancePoolForClasses`1.ReturnInstance(`0)">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.LocklessInstancePoolGeneric`1">
      <summary>
            This class implements semantics of containing multiple instances of some type, with methods for taking and returning instances.
            This class is fully threadsafe and does not use locks in its implementation.
            </summary>
      <typeparam name="TInstance">The type of the instances to hold.</typeparam>
      <remarks>
            One should use <see cref="T:UtilPack.DefaultLocklessInstancePoolForClasses`1" /> if <typeparamref name="TInstance" /> is known at compile time never to be a struct.
            This class is a bit slower than <see cref="T:UtilPack.DefaultLocklessInstancePoolForClasses`1" /> and contains different API.
            </remarks>
    </member>
    <member name="M:UtilPack.LocklessInstancePoolGeneric`1.#ctor">
      <summary>
            Creates new instance of <see cref="T:UtilPack.LocklessInstancePoolGeneric`1" />.
            </summary>
    </member>
    <member name="M:UtilPack.LocklessInstancePoolGeneric`1.TryTake(`0@)">
      <summary>
            Attempts to remove an instance from this <see cref="T:UtilPack.LocklessInstancePoolGeneric`1" />.
            </summary>
      <param name="item">When this method returns, this will contain instance of <typeparamref name="TInstance" /> if this method returned <c>true</c>, or default value of <typeparamref name="TInstance" /> if this method returned <c>false</c>.</param>
      <returns>
        <c>true</c> if an instance was acquired successfully; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.LocklessInstancePoolGeneric`1.TryPeek(`0@)">
      <summary>
            Attemts to fetch an instance from this <see cref="T:UtilPack.LocklessInstancePoolGeneric`1" /> without removing it.
            </summary>
      <param name="item">When this method returns, this will contain instance of <typeparamref name="TInstance" /> if this method returned <c>true</c>, or default value of <typeparamref name="TInstance" /> if this method returned <c>false</c>.</param>
      <returns>
        <c>true</c> if an instance was fetched successfully; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.LocklessInstancePoolGeneric`1.ReturnInstance(`0)">
      <summary>
            Returns an existing instance to this <see cref="T:UtilPack.LocklessInstancePoolGeneric`1" />.
            </summary>
      <param name="item">The instance to return.</param>
    </member>
    <member name="T:UtilPack.InstanceHolder`1">
      <summary>
            This class is generic instance holder, suitable to use with <see cref="T:UtilPack.LocklessInstancePoolForClassesNoHeapAllocations`1" />.
            </summary>
      <typeparam name="TInstance">The type of actual instance.</typeparam>
    </member>
    <member name="M:UtilPack.InstanceHolder`1.#ctor(`0)">
      <summary>
            Creates new instance of <see cref="T:UtilPack.InstanceHolder`1" />.
            </summary>
      <param name="instance">The actual instance.</param>
    </member>
    <member name="P:UtilPack.InstanceHolder`1.Instance">
      <summary>
            Gets the current instance.
            </summary>
      <value>The current instance.</value>
    </member>
    <member name="P:UtilPack.InstanceHolder`1.Next">
      <summary>
            Gets or sets the next <see cref="T:UtilPack.InstanceHolder`1" /> in the instance holder chain.
            This should never be used directly - instead let <see cref="T:UtilPack.LocklessInstancePoolForClassesNoHeapAllocations`1" /> manage this.
            </summary>
      <value>The next <see cref="T:UtilPack.InstanceHolder`1" /> in the instance holder chain.</value>
    </member>
    <member name="T:UtilPack.LocklessInstancePoolForClassesNoHeapAllocations`1">
      <summary>
            This class acts as instance pool for types, which can hold their 'next' value.
            </summary>
      <typeparam name="TInstance">The type of instances.</typeparam>
    </member>
    <member name="M:UtilPack.LocklessInstancePoolForClassesNoHeapAllocations`1.#ctor">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.LocklessInstancePoolForClassesNoHeapAllocations`1" /></summary>
    </member>
    <member name="M:UtilPack.LocklessInstancePoolForClassesNoHeapAllocations`1.TakeInstance">
      <inheritdoc />
    </member>
    <member name="M:UtilPack.LocklessInstancePoolForClassesNoHeapAllocations`1.ReturnInstance(`0)">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.InstanceWithNextInfo`1">
      <summary>
            This inteface captures constraints required for <see cref="T:UtilPack.LocklessInstancePoolForClassesNoHeapAllocations`1" /></summary>
      <typeparam name="TInstance">The type of instance.</typeparam>
    </member>
    <member name="P:UtilPack.InstanceWithNextInfo`1.Next">
      <summary>
            Gets or sets the instance next in chain.
            </summary>
      <value>The instance next in chain.</value>
    </member>
    <member name="T:UtilPack.LazyKind">
      <summary>
            This enumeration will tell what type the <see cref="T:UtilPack.IAbstractLazy`1" /> actually is.
            </summary>
    </member>
    <member name="F:UtilPack.LazyKind.ReadOnly">
      <summary>
            The lazy is of type <see cref="T:UtilPack.ReadOnlyLazy`1" />.
            </summary>
    </member>
    <member name="F:UtilPack.LazyKind.ReadOnlyResettable">
      <summary>
            The lazy is of type <see cref="T:UtilPack.ReadOnlyResettableLazy`1" />.
            </summary>
    </member>
    <member name="F:UtilPack.LazyKind.Writeable">
      <summary>
            The lazy is of type <see cref="T:UtilPack.WriteableLazy`1" />.
            </summary>
    </member>
    <member name="F:UtilPack.LazyKind.WriteableResettable">
      <summary>
            The lazy is of type <see cref="T:UtilPack.WriteableResettableLazy`1" />.
            </summary>
    </member>
    <member name="T:UtilPack.LazyWriteabilityKind">
      <summary>
            This enumeration describes whether the lazy object can be written.
            </summary>
    </member>
    <member name="F:UtilPack.LazyWriteabilityKind.ReadOnly">
      <summary>
            The lazy value can not be overwritten.
            </summary>
    </member>
    <member name="F:UtilPack.LazyWriteabilityKind.Writeable">
      <summary>
            The lazy value can be overwritten.
            </summary>
    </member>
    <member name="T:UtilPack.LazyResettabilityKind">
      <summary>
            This enumeration describes whether the lazy object can be re-set to its original value.
            </summary>
    </member>
    <member name="F:UtilPack.LazyResettabilityKind.NotResettable">
      <summary>
            The lazy value can not be re-set.
            </summary>
    </member>
    <member name="F:UtilPack.LazyResettabilityKind.Resettable">
      <summary>
            The lazy value can be re-set.
            </summary>
    </member>
    <member name="T:UtilPack.IAbstractLazy`1">
      <summary>
            This is common interface for all lazy types in this library.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
      <seealso cref="T:UtilPack.IReadOnlyLazy`1" />
      <seealso cref="T:UtilPack.IResettableLazy`1" />
      <seealso cref="T:UtilPack.IWriteableLazy`1" />
      <seealso cref="T:UtilPack.ReadOnlyLazy`1" />
      <seealso cref="T:UtilPack.ReadOnlyResettableLazy`1" />
      <seealso cref="T:UtilPack.WriteableLazy`1" />
      <seealso cref="T:UtilPack.WriteableResettableLazy`1" />
    </member>
    <member name="P:UtilPack.IAbstractLazy`1.Value">
      <summary>
            Lazily initializes the value, if required, and returns it.
            </summary>
    </member>
    <member name="P:UtilPack.IAbstractLazy`1.IsValueCreated">
      <summary>
            Checks whether the value has been initialized.
            </summary>
      <value>
        <c>true</c>, if value has been initialized; <c>false</c> otherwise.</value>
    </member>
    <member name="P:UtilPack.IAbstractLazy`1.LazyKind">
      <summary>
            Gets the <see cref="T:UtilPack.LazyKind" /> enumeration telling which lazy type this object really is.
            </summary>
    </member>
    <member name="P:UtilPack.IAbstractLazy`1.WriteabilityKind">
      <summary>
            Gets the <see cref="T:UtilPack.LazyWriteabilityKind" /> of this lazy.
            </summary>
      <value>The <see cref="T:UtilPack.LazyWriteabilityKind" /> of this lazy.</value>
    </member>
    <member name="P:UtilPack.IAbstractLazy`1.ResettabilityKind">
      <summary>
            Gets the <see cref="T:UtilPack.LazyResettabilityKind" /> of this lazy.
            </summary>
      <value>The <see cref="T:UtilPack.LazyResettabilityKind" /> of this lazy.</value>
    </member>
    <member name="T:UtilPack.IReadOnlyLazy`1">
      <summary>
            This is interface implemented by read-only lazies: <see cref="T:UtilPack.ReadOnlyLazy`1" /> and <see cref="T:UtilPack.ReadOnlyResettableLazy`1" />.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
    </member>
    <member name="T:UtilPack.IResettableLazy`1">
      <summary>
            This is interface implemented by lazies which provide reset-functionality: <see cref="T:UtilPack.ReadOnlyResettableLazy`1" /> and <see cref="T:UtilPack.WriteableResettableLazy`1" />.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
    </member>
    <member name="M:UtilPack.IResettableLazy`1.Reset">
      <summary>
            Resets the 
            </summary>
    </member>
    <member name="T:UtilPack.IWriteableLazy`1">
      <summary>
            This is interface implemented by lazies which provide write-functionality: <see cref="T:UtilPack.WriteableLazy`1" /> and <see cref="T:UtilPack.WriteableResettableLazy`1" />.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
    </member>
    <member name="P:UtilPack.IWriteableLazy`1.Value">
      <summary>
            Gets or sets the value.
            </summary>
      <remarks>
            The setter can be used at any time, before or after calling getter.
            Once the setter has been called, the value returned by getter will be the one passed to setter.
            The lazy initializer will be called if getter is used before setter.
            </remarks>
      <value>
            The lazily initialized or manually set value.
            </value>
    </member>
    <member name="T:UtilPack.AbstractLazy`1">
      <summary>
            This is base class for all types providing lazy initialization functionality.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
      <seealso cref="T:UtilPack.ReadOnlyLazy`1" />
      <seealso cref="T:UtilPack.ReadOnlyResettableLazy`1" />
      <seealso cref="T:UtilPack.WriteableLazy`1" />
      <seealso cref="T:UtilPack.WriteableResettableLazy`1" />
    </member>
    <member name="P:UtilPack.AbstractLazy`1.IsValueCreated">
      <summary>
            Checks whether the value has been initialized.
            </summary>
      <value>
        <c>true</c>, if value has been initialized; <c>false</c> otherwise.</value>
    </member>
    <member name="P:UtilPack.AbstractLazy`1.LazyKind">
      <summary>
            Gets the <see cref="T:UtilPack.LazyKind" /> enumeration telling which lazy type this object really is.
            </summary>
    </member>
    <member name="P:UtilPack.AbstractLazy`1.WriteabilityKind">
      <summary>
            Gets the <see cref="T:UtilPack.LazyWriteabilityKind" /> of this lazy.
            </summary>
      <value>The <see cref="T:UtilPack.LazyWriteabilityKind" /> of this lazy.</value>
    </member>
    <member name="P:UtilPack.AbstractLazy`1.ResettabilityKind">
      <summary>
            Gets the <see cref="T:UtilPack.LazyResettabilityKind" /> of this lazy.
            </summary>
      <value>The <see cref="T:UtilPack.LazyResettabilityKind" /> of this lazy.</value>
    </member>
    <member name="T:UtilPack.ReadOnlyLazy`1">
      <summary>
            This class implements the <see cref="T:UtilPack.IReadOnlyLazy`1" /> functionality.
            In essence, it is identical to <see cref="T:System.Lazy`1" /> class.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
    </member>
    <member name="P:UtilPack.ReadOnlyLazy`1.Value">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.ReadOnlyLazy`1.IsValueCreated">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.ReadOnlyLazy`1.LazyKind">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.ReadOnlyLazy`1.WriteabilityKind">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.ReadOnlyLazy`1.ResettabilityKind">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.LazyWithSetter`1">
      <summary>
            This class provides some common functionality for <see cref="T:UtilPack.ReadOnlyResettableLazy`1" />, <see cref="T:UtilPack.WriteableLazy`1" />, and <see cref="T:UtilPack.WriteableResettableLazy`1" /> classes.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
    </member>
    <member name="P:UtilPack.LazyWithSetter`1.IsValueCreated">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.LazyWithSetter`1.LazyThreadSafety">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.ReadOnlyResettableLazy`1">
      <summary>
            This class provides functionality of read-only lazily initializable value, with a option to reset the value to its initial state.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
      <seealso cref="T:UtilPack.IReadOnlyLazy`1" />
      <seealso cref="T:UtilPack.IResettableLazy`1" />
    </member>
    <member name="M:UtilPack.ReadOnlyResettableLazy`1.Reset">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.ReadOnlyResettableLazy`1.Value">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.ReadOnlyResettableLazy`1.LazyKind">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.ReadOnlyResettableLazy`1.WriteabilityKind">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.ReadOnlyResettableLazy`1.ResettabilityKind">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.AbstractWriteableLazy`1">
      <summary>
            This class provides some common functionality for <see cref="T:UtilPack.WriteableLazy`1" /> and <see cref="T:UtilPack.WriteableResettableLazy`1" />.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
    </member>
    <member name="P:UtilPack.AbstractWriteableLazy`1.Value">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.AbstractWriteableLazy`1.IsValueCreated">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.WriteableLazy`1">
      <summary>
            This class provides functionality of writeable lazy, where the lazy value may be manually re-specified or overwritten.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
    </member>
    <member name="P:UtilPack.WriteableLazy`1.LazyKind">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.WriteableLazy`1.WriteabilityKind">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.WriteableLazy`1.ResettabilityKind">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.WriteableResettableLazy`1">
      <summary>
            This class provides functionality of writeable lazy value, where the lazy value may be manually re-specified or overwritten, and with an option to reset the lazy value to its initial state.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
      <seealso cref="T:UtilPack.IWriteableLazy`1" />
      <seealso cref="T:UtilPack.IResettableLazy`1" />
    </member>
    <member name="M:UtilPack.WriteableResettableLazy`1.Reset">
      <summary>
            Resets the current value to the one provided by lazy value factory, but only if the current value has not been set through <see cref="P:UtilPack.AbstractWriteableLazy`1.Value" /> setter.
            </summary>
    </member>
    <member name="M:UtilPack.WriteableResettableLazy`1.Reset(System.Boolean)">
      <summary>
            Resets the current value to the one provided by lazy value factory.
            </summary>
      <param name="resetEvenIfManuallySet">If this is <c>true</c>, then the value will be reset even if current value has been set through <see cref="P:UtilPack.AbstractWriteableLazy`1.Value" /> setter.</param>
    </member>
    <member name="P:UtilPack.WriteableResettableLazy`1.LazyKind">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.WriteableResettableLazy`1.WriteabilityKind">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.WriteableResettableLazy`1.ResettabilityKind">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.LazyFactory">
      <summary>
            This is factory class to create various lazily initializable objects provided by this library.
            </summary>
      <seealso cref="T:UtilPack.IAbstractLazy`1" />
      <seealso cref="T:UtilPack.IReadOnlyLazy`1" />
      <seealso cref="T:UtilPack.IResettableLazy`1" />
      <seealso cref="T:UtilPack.IWriteableLazy`1" />
      <seealso cref="T:UtilPack.ReadOnlyLazy`1" />
      <seealso cref="T:UtilPack.ReadOnlyResettableLazy`1" />
      <seealso cref="T:UtilPack.WriteableLazy`1" />
      <seealso cref="T:UtilPack.WriteableResettableLazy`1" />
    </member>
    <member name="M:UtilPack.LazyFactory.NewLazy``1(UtilPack.LazyKind,System.Func{``0},System.Threading.LazyThreadSafetyMode)">
      <summary>
            Creates a new lazy, type and behaviour of which will be decided by given <see cref="T:UtilPack.LazyKind" /> enumeration.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
      <param name="kind">The <see cref="T:UtilPack.LazyKind" />.</param>
      <param name="valueFactory">The value factory, may be <c>null</c>.</param>
      <param name="threadSafety">The <see cref="T:System.Threading.LazyThreadSafetyMode" />.</param>
      <returns>A lazily initializing object, of type 
            <list type="bullet"><item><description><see cref="T:UtilPack.ReadOnlyLazy`1" />, if <paramref name="kind" /> is <see cref="F:UtilPack.LazyKind.ReadOnly" />,</description></item><item><description><see cref="T:UtilPack.ReadOnlyResettableLazy`1" />, if <paramref name="kind" /> is <see cref="F:UtilPack.LazyKind.ReadOnlyResettable" />,</description></item><item><description><see cref="T:UtilPack.WriteableLazy`1" />, if <paramref name="kind" /> is <see cref="F:UtilPack.LazyKind.Writeable" />, or</description></item><item><description><see cref="T:UtilPack.WriteableResettableLazy`1" />, if <paramref name="kind" /> is <see cref="F:UtilPack.LazyKind.WriteableResettable" />.</description></item></list></returns>
      <exception cref="T:System.ArgumentException">If <paramref name="kind" /> is not one of the values specified in <see cref="T:UtilPack.LazyKind" /> enumeration.</exception>
    </member>
    <member name="M:UtilPack.LazyFactory.NewReadOnlyLazy``1(System.Func{``0},System.Threading.LazyThreadSafetyMode)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.ReadOnlyLazy`1" /> with given value factory and thread safety.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
      <param name="valueFactory">The value factory, may be <c>null</c>.</param>
      <param name="threadSafety">The <see cref="T:System.Threading.LazyThreadSafetyMode" />.</param>
      <returns>A new instance of <see cref="T:UtilPack.ReadOnlyLazy`1" /> with given value factory and thread safety.</returns>
    </member>
    <member name="M:UtilPack.LazyFactory.NewReadOnlyResettableLazy``1(System.Func{``0},System.Threading.LazyThreadSafetyMode)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.ReadOnlyResettableLazy`1" /> with given value factory and thread safety.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
      <param name="valueFactory">The value factory. May be <c>null</c>.</param>
      <param name="threadSafety">The <see cref="T:System.Threading.LazyThreadSafetyMode" />.</param>
      <returns>A new instance of <see cref="T:UtilPack.ReadOnlyResettableLazy`1" /> with given value factory and thread safety.</returns>
    </member>
    <member name="M:UtilPack.LazyFactory.NewWriteableLazy``1(System.Func{``0},System.Threading.LazyThreadSafetyMode)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.WriteableLazy`1" /> with given value factory and thread safety.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
      <param name="valueFactory">The value factory. May be <c>null</c>.</param>
      <param name="threadSafety">The <see cref="T:System.Threading.LazyThreadSafetyMode" />.</param>
      <returns>A new instance of <see cref="T:UtilPack.WriteableLazy`1" /> with given value factory and thread safety.</returns>
    </member>
    <member name="M:UtilPack.LazyFactory.NewWriteableResettableLazy``1(System.Func{``0},System.Threading.LazyThreadSafetyMode)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.WriteableResettableLazy`1" /> with given value factory and thread safety.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
      <param name="valueFactory">The value factory. May be <c>null</c>.</param>
      <param name="threadSafety">The <see cref="T:System.Threading.LazyThreadSafetyMode" />.</param>
      <returns>A new instance of <see cref="T:UtilPack.WriteableResettableLazy`1" /> with given value factory and thread safety.</returns>
    </member>
    <member name="M:UtilPack.LazyFactory.NewResettableLazy``1(System.Boolean,System.Func{``0},System.Threading.LazyThreadSafetyMode)">
      <summary>
            Creates a new lazy, which will be <see cref="T:UtilPack.WriteableResettableLazy`1" /> or <see cref="T:UtilPack.ReadOnlyResettableLazy`1" />, depending on <paramref name="isWriteable" /> parameter.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
      <param name="isWriteable">Whether to create writeable resettable lazy.</param>
      <param name="valueFactory">The value factory. May be <c>null</c>.</param>
      <param name="threadSafety">The <see cref="T:System.Threading.LazyThreadSafetyMode" />.</param>
      <returns>A new instance of <see cref="T:UtilPack.WriteableResettableLazy`1" /> if <paramref name="isWriteable" /> is <c>true</c>; a new instance of <see cref="T:UtilPack.ReadOnlyResettableLazy`1" /> otherwise.</returns>
    </member>
    <member name="M:UtilPack.LazyFactory.NewWriteableLazy``1(System.Boolean,System.Func{``0},System.Threading.LazyThreadSafetyMode)">
      <summary>
            Creates a new lazy, which will be <see cref="T:UtilPack.WriteableResettableLazy`1" /> or <see cref="T:UtilPack.WriteableLazy`1" />, depending on <paramref name="isResettable" /> parameter.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
      <param name="isResettable">Whether to create writeable resettable lazy.</param>
      <param name="valueFactory">The value factory. May be <c>null</c>.</param>
      <param name="threadSafety">The <see cref="T:System.Threading.LazyThreadSafetyMode" />.</param>
      <returns>A new instance of <see cref="T:UtilPack.WriteableResettableLazy`1" /> if <paramref name="isResettable" /> is <c>true</c>; a new instance of <see cref="T:UtilPack.WriteableLazy`1" /> otherwise.</returns>
    </member>
    <member name="M:UtilPack.LazyFactory.NewReadOnlyLazy``1(System.Boolean,System.Func{``0},System.Threading.LazyThreadSafetyMode)">
      <summary>
            Creates a new lazy, which will be <see cref="T:UtilPack.ReadOnlyResettableLazy`1" /> or <see cref="T:UtilPack.ReadOnlyLazy`1" />, depending on <paramref name="isResettable" /> parameter.
            </summary>
      <typeparam name="T">The type of lazily initialized object.</typeparam>
      <param name="isResettable">Whether to create writeable resettable lazy.</param>
      <param name="valueFactory">The value factory. May be <c>null</c>.</param>
      <param name="threadSafety">The <see cref="T:System.Threading.LazyThreadSafetyMode" />.</param>
      <returns>A new instance of <see cref="T:UtilPack.ReadOnlyResettableLazy`1" /> if <paramref name="isResettable" /> is <c>true</c>; a new instance of <see cref="T:UtilPack.ReadOnlyLazy`1" /> otherwise.</returns>
    </member>
    <member name="M:UtilPack.LazyFactory.NewResettableOnErrorLazy``2(``0@,System.Func{``1},System.Threading.LazyThreadSafetyMode,UtilPack.LazyWriteabilityKind)">
      <summary>
            Creates a new resettable lazy, which will re-set the lazy value if an exception is thrown from value factory.
            </summary>
      <typeparam name="TLazy">The type of the lazy.</typeparam>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="lazy">The reference to lazy variable.</param>
      <param name="valueFactory">The value factory.</param>
      <param name="threadSafety">The <see cref="T:System.Threading.LazyThreadSafetyMode" />.</param>
      <param name="writeability">The writeability of the lazy to create, <see cref="F:UtilPack.LazyWriteabilityKind.ReadOnly" /> for <see cref="T:UtilPack.ReadOnlyResettableLazy`1" />, and <see cref="F:UtilPack.LazyWriteabilityKind.Writeable" /> for <see cref="T:UtilPack.WriteableResettableLazy`1" />.</param>
      <exception cref="T:System.InvalidCastException">If <typeparamref name="TLazy" /> and <paramref name="writeability" /> do not match.</exception>
    </member>
    <member name="T:UtilPack.GenericEventHandler`1">
      <summary>
            This delegate type is alternative for <see cref="T:System.EventHandler`1" />.
            It differs from the <see cref="T:System.EventHandler`1" /> in the following three ways:
            <list type="bullet"><item><description>The generic argument <typeparamref name="TArgs" /> has <c>in</c> contravariance specification,</description></item><item><description>The generic argument <typeparamref name="TArgs" /> no longer has a inheritance constraint, and</description></item><item><description>The <c>sender</c> parameter of the <see cref="T:System.EventHandler`1" /> is missing.</description></item></list></summary>
      <typeparameter name="TArgs">The type of the arguments this delegate will receive.</typeparameter>
    </member>
    <member name="T:UtilPack.Identity`1">
      <summary>
            This class holds reference to <see cref="T:System.Func`2" /> which directly returns the given argument, i.e. identity function.
            </summary>
      <typeparam name="T">The type of argument and return value of callback.</typeparam>
    </member>
    <member name="P:UtilPack.Identity`1.Function">
      <summary>
            Gets the identity function for type <typeparamref name="T" />.
            </summary>
      <value>The identity function for type <typeparamref name="T" />.</value>
    </member>
    <member name="T:UtilPack.ResultOrNone`1">
      <summary>
            This struct captures situation when result can be unavailable (due to error or something else).
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
    </member>
    <member name="M:UtilPack.ResultOrNone`1.#ctor(`0)">
      <summary>
            Creates a new <see cref="T:UtilPack.ResultOrNone`1" /> with given result.
            </summary>
      <param name="result">The result.</param>
    </member>
    <member name="P:UtilPack.ResultOrNone`1.Result">
      <summary>
            Gets the result, or returns default for <typeparamref name="TResult" /> if no result has been specified.
            </summary>
      <value>The result that was given, or default ofr <typeparamref name="TResult" />.</value>
      <seealso cref="P:UtilPack.ResultOrNone`1.HasResult" />
    </member>
    <member name="P:UtilPack.ResultOrNone`1.HasResult">
      <summary>
            Gets the value indicating whether this <see cref="T:UtilPack.ResultOrNone`1" /> was given a result.
            This is useful to separate scenario when the result was given, but it is actually default for <typeparamref name="TResult" />.
            </summary>
      <value>The value indicating whether this <see cref="T:UtilPack.ResultOrNone`1" /> was given a result.</value>
    </member>
    <member name="M:UtilPack.ResultOrNone`1.op_Implicit(`0)~UtilPack.ResultOrNone{`0}">
      <summary>
            Implicitly casts the given result object to <see cref="T:UtilPack.ResultOrNone`1" />,
            </summary>
      <param name="result">The result.</param>
    </member>
    <member name="M:UtilPack.ResultOrNone`1.op_Explicit(UtilPack.ResultOrNone{`0})~`0">
      <summary>
            Explicitly casts the given <see cref="T:UtilPack.ResultOrNone`1" /> to result.
            Will throw, if the <paramref name="resultOrNone" /> does not have result specified.
            </summary>
      <param name="resultOrNone">The <see cref="T:UtilPack.ResultOrNone`1" />.</param>
      <exception cref="T:System.InvalidOperationException">If <paramref name="resultOrNone" /> does not have result specified (its <see cref="P:UtilPack.ResultOrNone`1.HasResult" /> property returns <c>false</c>).</exception>
    </member>
    <member name="T:UtilPack.EitherOr`2">
      <summary>
            This struct captures the value which can be one of two mutually exclusive types.
            </summary>
      <typeparam name="T1">The type for first possible value.</typeparam>
      <typeparam name="T2">The type for second possible value.</typeparam>
    </member>
    <member name="M:UtilPack.EitherOr`2.#ctor(`0)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.EitherOr`2" /> bound to value of the first type <typeparamref name="T1" />.
            </summary>
      <param name="first">The first value.</param>
    </member>
    <member name="M:UtilPack.EitherOr`2.#ctor(`1)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.EitherOr`2" /> bound to value of the second type <typeparamref name="T2" />.
            </summary>
      <param name="second">The second value.</param>
    </member>
    <member name="P:UtilPack.EitherOr`2.First">
      <summary>
            Gets the value of the type <typeparamref name="T1" />, or throws an exception if this <see cref="T:UtilPack.EitherOr`2" /> is not bound to first type.
            </summary>
      <value>The value of the type <typeparamref name="T1" />.</value>
      <exception cref="T:System.InvalidOperationException">If this <see cref="T:UtilPack.EitherOr`2" /> is not bound to first type (the <see cref="P:UtilPack.EitherOr`2.IsFirst" /> returns <c>false</c>).</exception>
    </member>
    <member name="P:UtilPack.EitherOr`2.Second">
      <summary>
            Gets the value of the type <typeparamref name="T2" />, or throws an exception if this <see cref="T:UtilPack.EitherOr`2" /> is not bound to second type.
            </summary>
      <value>The value of the type <typeparamref name="T2" />.</value>
      <exception cref="T:System.InvalidOperationException">If this <see cref="T:UtilPack.EitherOr`2" /> is not bound to second type (the <see cref="P:UtilPack.EitherOr`2.IsSecond" /> returns <c>false</c>).</exception>
    </member>
    <member name="P:UtilPack.EitherOr`2.IsFirst">
      <summary>
            Gets the value indicating whether this <see cref="T:UtilPack.EitherOr`2" /> is bound to first type <typeparamref name="T1" />.
            </summary>
      <value>The value indicating whether this <see cref="T:UtilPack.EitherOr`2" /> is bound to first type <typeparamref name="T1" />.</value>
    </member>
    <member name="P:UtilPack.EitherOr`2.IsSecond">
      <summary>
            Gets the value indicating whether this <see cref="T:UtilPack.EitherOr`2" /> is bound to second type <typeparamref name="T2" />.
            </summary>
      <value>The value indicating whether this <see cref="T:UtilPack.EitherOr`2" /> is bound to second type <typeparamref name="T2" />.</value>
    </member>
    <member name="M:UtilPack.EitherOr`2.op_Implicit(`0)~UtilPack.EitherOr{`0,`1}">
      <summary>
            Performs implicit conversion of the value of the first type <typeparamref name="T1" /> to <see cref="T:UtilPack.EitherOr`2" /> bound to the first type.
            </summary>
      <param name="first">The value of the first type <typeparamref name="T1" />.</param>
    </member>
    <member name="M:UtilPack.EitherOr`2.op_Implicit(`1)~UtilPack.EitherOr{`0,`1}">
      <summary>
            Performs implicit conversion of the value of the second type <typeparamref name="T2" /> to <see cref="T:UtilPack.EitherOr`2" /> bound to the second type.
            </summary>
      <param name="second">The value of the second type <typeparamref name="T2" />.</param>
    </member>
    <member name="M:UtilPack.EitherOr`2.op_Explicit(UtilPack.EitherOr{`0,`1})~`0">
      <summary>
            Performs explicit conversion of the <see cref="T:UtilPack.EitherOr`2" /> to the value of the first type <typeparamref name="T1" />.
            </summary>
      <param name="either">The <see cref="T:UtilPack.EitherOr`2" />.</param>
      <exception cref="T:System.InvalidOperationException">If <paramref name="either" /> is not bound to first type (its <see cref="P:UtilPack.EitherOr`2.IsFirst" /> returns <c>false</c>).</exception>
    </member>
    <member name="M:UtilPack.EitherOr`2.op_Explicit(UtilPack.EitherOr{`0,`1})~`1">
      <summary>
            Performs explicit conversion of the <see cref="T:UtilPack.EitherOr`2" /> to the value of the second type <typeparamref name="T2" />.
            </summary>
      <param name="either">The <see cref="T:UtilPack.EitherOr`2" />.</param>
      <exception cref="T:System.InvalidOperationException">If <paramref name="either" /> is not bound to second type (its <see cref="P:UtilPack.EitherOr`2.IsSecond" /> returns <c>false</c>).</exception>
    </member>
    <member name="T:UtilPack.EventArgsWithAsyncContext`1">
      <summary>
            This interface adds a way to add an awaitable object.
            Once event is invoked, the event caller may wait for all the awaitables.
            This way the <c>async void</c> methods can be avoided.
            </summary>
      <typeparam name="TAwaitable">The type of the awaitable.</typeparam>
      <remarks>
            Because of how <c>public async void</c> methods behave, they only make sense when they are run in UI thread or similar (otherwise, they will cause hard crash, <see href="https://msdn.microsoft.com/en-us/magazine/jj991977.aspx" />).
            </remarks>
    </member>
    <member name="M:UtilPack.EventArgsWithAsyncContext`1.AddAwaitable(`0)">
      <summary>
            Adds an awaitable object to the current list of awaitables of this <see cref="T:UtilPack.EventArgsWithAsyncContext`1" />.
            </summary>
      <param name="awaitable">The awaitable to be added.</param>
    </member>
    <member name="T:UtilPack.EventArgsWithAsyncContext">
      <summary>
            This class restricts the type argument of <see cref="T:UtilPack.EventArgsWithAsyncContext`1" /> to <see cref="T:System.Threading.Tasks.Task" />.
            </summary>
    </member>
    <member name="T:UtilPack.EventArgsWithAsyncContextImpl`1">
      <summary>
            This class provides default implementation for <see cref="T:UtilPack.EventArgsWithAsyncContext`1" /></summary>
      <typeparam name="TAwaitable">The type of the awaitable.</typeparam>
      <remarks>
            Because of how <c>public async void</c> methods behave, they only make sense when they are run in UI thread or similar (otherwise, they will cause hard crash, <see href="https://msdn.microsoft.com/en-us/magazine/jj991977.aspx" />).
            </remarks>
    </member>
    <member name="M:UtilPack.EventArgsWithAsyncContextImpl`1.#ctor">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.EventArgsWithAsyncContext`1" /></summary>
    </member>
    <member name="M:UtilPack.EventArgsWithAsyncContextImpl`1.AddAwaitable(`0)">
      <summary>
            Adds the given awaitable to the list of awaitables.
            </summary>
    </member>
    <member name="M:UtilPack.EventArgsWithAsyncContextImpl`1.GetAwaitableArray">
      <summary>
            Gets the array of awaitables added to the list of awaitables, or <c>null</c> if no awaitables have been added.
            </summary>
      <returns>The array of awaitables added to the list of awaitables, or <c>null</c> if no awaitables have been added.</returns>
    </member>
    <member name="T:UtilPack.EventArgsWithAsyncContextImpl">
      <summary>
            This class restricts the type argument of <see cref="T:UtilPack.EventArgsWithAsyncContextImpl`1" /> to <see cref="T:System.Threading.Tasks.Task" />.
            </summary>
    </member>
    <member name="T:UtilPack.TaskUtils">
      <summary>
            The .NET Standard library does not have Task.CompletedTask property (at least for all versions).
            Hence, this class provides it.
            </summary>
    </member>
    <member name="P:UtilPack.TaskUtils.CompletedTask">
      <summary>
            Gets the task which is completed.
            </summary>
    </member>
    <member name="T:UtilPack.IAsyncDisposable">
      <summary>
            This interface provides a method which performs disposing of some resource asynchronously.
            </summary>
    </member>
    <member name="M:UtilPack.IAsyncDisposable.DisposeAsync(System.Threading.CancellationToken)">
      <summary>
            Performs the disposing of some resource asynchrnonously, with given optional <see cref="T:System.Threading.CancellationToken" />.
            </summary>
      <param name="token">The optional <see cref="T:System.Threading.CancellationToken" />.</param>
      <returns>The task to await for.</returns>
    </member>
    <member name="T:UtilPack.AsyncLazy`1">
      <summary>
            Provides support for asynchronous lazy initialization. This type is fully threadsafe.
            The class is from <see href="https://blog.stephencleary.com/2012/08/asynchronous-lazy-initialization.html" /> with few small modifications.
            </summary>
      <typeparam name="T">The type of object that is being asynchronously initialized.</typeparam>
    </member>
    <member name="M:UtilPack.AsyncLazy`1.#ctor(System.Func{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:UtilPack.AsyncLazy`1" /> class.
            </summary>
      <param name="factory">The delegate that is invoked on a background thread to produce the value when it is needed.</param>
    </member>
    <member name="M:UtilPack.AsyncLazy`1.#ctor(System.Func{System.Threading.Tasks.Task{`0}})">
      <summary>
            Initializes a new instance of the <see cref="T:UtilPack.AsyncLazy`1" /> class.
            </summary>
      <param name="asyncFactory">The asynchronous delegate that is invoked on a background thread to produce the value when it is needed.</param>
    </member>
    <member name="M:UtilPack.AsyncLazy`1.GetAwaiter">
      <summary>
            Asynchronous infrastructure support. This method permits instances of <see cref="T:UtilPack.AsyncLazy`1" /> to be awaited.
            </summary>
    </member>
    <member name="M:UtilPack.AsyncLazy`1.Start">
      <summary>
            Starts the asynchronous initialization, if it has not already started.
            </summary>
    </member>
    <member name="T:UtilPack.ReadOnlyResettableAsyncLazy`1">
      <summary>
            This class combines the asynchronousness of <see cref="T:UtilPack.AsyncLazy`1" /> with the resettability of <see cref="T:UtilPack.ReadOnlyResettableLazy`1" />.
            </summary>
      <typeparam name="T"></typeparam>
    </member>
    <member name="M:UtilPack.ReadOnlyResettableAsyncLazy`1.#ctor(System.Func{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:UtilPack.ReadOnlyResettableAsyncLazy`1" /> class.
            </summary>
      <param name="factory">The delegate that is invoked on a background thread to produce the value when it is needed.</param>
    </member>
    <member name="M:UtilPack.ReadOnlyResettableAsyncLazy`1.#ctor(System.Func{System.Threading.Tasks.Task{`0}})">
      <summary>
            Initializes a new instance of the <see cref="T:UtilPack.ReadOnlyResettableAsyncLazy`1" /> class.
            </summary>
      <param name="asyncFactory">The asynchronous delegate that is invoked on a background thread to produce the value when it is needed.</param>
    </member>
    <member name="M:UtilPack.ReadOnlyResettableAsyncLazy`1.GetAwaiter">
      <summary>
            Asynchronous infrastructure support. This method permits instances of <see cref="T:UtilPack.ReadOnlyResettableAsyncLazy`1" /> to be awaited.
            </summary>
    </member>
    <member name="M:UtilPack.ReadOnlyResettableAsyncLazy`1.Start">
      <summary>
            Starts the asynchronous initialization, if it has not already started.
            </summary>
    </member>
    <member name="M:UtilPack.ReadOnlyResettableAsyncLazy`1.Reset">
      <summary>
            Resets this <see cref="T:UtilPack.ReadOnlyResettableAsyncLazy`1" />.
            </summary>
    </member>
    <member name="T:UtilPack.Transformable`2">
      <summary>
            This class performs tasks related to objects to "change type", typically on first access (e.g. from <see cref="T:System.Nullable`1" /> to actual object).
            Furthermore, this class supports the transition which is done asynchronously, unlike <see cref="T:System.Lazy`1" />.
            </summary>
      <typeparam name="T1">The type of the initial value.</typeparam>
      <typeparam name="T2">The type of the transformed value.</typeparam>
    </member>
    <member name="M:UtilPack.Transformable`2.#ctor(`0)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.Transformable`2" /> with given original value.
            </summary>
      <param name="value">The value of the original type.</param>
    </member>
    <member name="P:UtilPack.Transformable`2.Original">
      <summary>
            Gets the original value, or throws an exception if original value is no longer available.
            </summary>
      <value>The original value, or throws an exception if original value is no longer available.</value>
      <exception cref="T:System.InvalidOperationException">If original value is no longer available, because of asynchronous transition started, or possibly asynchronous transition completed.</exception>
    </member>
    <member name="P:UtilPack.Transformable`2.Transformed">
      <summary>
            Gets the transformed value, or throws an exception if transformed value is not available yet.
            </summary>
      <value>The transformed value, or throws an exception if transformed value is not available yet.</value>
      <exception cref="T:System.InvalidOperationException">If transformed value is not yet available.</exception>
    </member>
    <member name="P:UtilPack.Transformable`2.IsOriginal">
      <summary>
            Gets the value indicating whether this <see cref="T:UtilPack.Transformable`2" /> is of original value.
            </summary>
      <value>The value indicating whether this <see cref="T:UtilPack.Transformable`2" /> is of original value.</value>
    </member>
    <member name="P:UtilPack.Transformable`2.IsTransformed">
      <summary>
            Gets the value indicating whether this <see cref="T:UtilPack.Transformable`2" /> is of transformed value.
            </summary>
      <value>The value indicating whether this <see cref="T:UtilPack.Transformable`2" /> is of transformed value.</value>
    </member>
    <member name="M:UtilPack.Transformable`2.TryTransition(System.Func{`0,`1})">
      <summary>
            Tries synchronous transition from original value to the transformed value returned by given lambda.
            </summary>
      <param name="transitioner">The lambda to return transitioned value.</param>
      <returns>
        <c>true</c> if transformation from original to the value returned by lambda was successful; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.Transformable`2.TryTransitionAsync(System.Func{`0,System.Threading.Tasks.Task{`1}})">
      <summary>
            Tries asynchronous transition from original value to the transformed value returned by given asynchronous lambda.
            </summary>
      <param name="transitioner">The asynchronous lambda to return transitioned value.</param>
      <returns>
        <c>true</c> if transformation from original to the value returned by lambda was successful; <c>false</c> otherwise.</returns>
    </member>
    <member name="T:UtilPack.ResettableTransformable`2">
      <summary>
            Augments the <see cref="T:UtilPack.Transformable`2" /> class with possibility of resetting back to original value.
            </summary>
      <typeparam name="T1">The type of the initial value.</typeparam>
      <typeparam name="T2">The type of the transformed value.</typeparam>
    </member>
    <member name="M:UtilPack.ResettableTransformable`2.#ctor(`0)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.ResettableTransformable`2" /> with given original value.
            </summary>
      <param name="value">The value of the original type.</param>
    </member>
    <member name="M:UtilPack.ResettableTransformable`2.TryReset">
      <summary>
            Tries to reset the current value back to the original value.
            </summary>
      <returns>
        <c>true</c> if reset was successful; <c>false</c> otherwise.</returns>
    </member>
    <member name="T:UtilPack.Multiplexer`2">
      <summary>
            This class represents abstract multiplexor of values based on keys.
            </summary>
      <typeparam name="TKey">The type of keys to base multiplexing on.</typeparam>
      <typeparam name="TValue">The type of values being multiplexed.</typeparam>
      <remarks>
            The values being multiplexed are assumed to have the feature of being of same type whether they represent many or one specific thing.
            One example of this kind of type is <see cref="T:System.Delegate" />: it will be of the same type whether it has one or many handlers.
            </remarks>
    </member>
    <member name="M:UtilPack.Multiplexer`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.Multiplexer`2" /> with given combiner and remover callbacks, and optional equality comparer for keys.
            </summary>
      <param name="equalityComparer">The optional equality comparer for keys.</param>
    </member>
    <member name="M:UtilPack.Multiplexer`2.AddValueFor(`0,`1)">
      <summary>
            Multiplexes given value for given key.
            </summary>
      <param name="key">The key.</param>
      <param name="value">The value to multiplex.</param>
      <remarks>Will do nothing if <paramref name="value" /> is <c>null</c>.</remarks>
    </member>
    <member name="M:UtilPack.Multiplexer`2.RemoveValueFor(`0,`1)">
      <summary>
            De-multiplexes given value for given key.
            </summary>
      <param name="key">The key.</param>
      <param name="value">The value to de-multiplex.</param>
      <remarks>Will do nothing if <paramref name="value" /> is <c>null</c>.</remarks>
    </member>
    <member name="M:UtilPack.Multiplexer`2.TryGetMultiplexedValue(`0,`1@)">
      <summary>
            Tries to get the multiplexed value for given key.
            </summary>
      <param name="key">The key.</param>
      <param name="value">This will contain the multiplexed value, if return value of this method is <c>true</c>.</param>
      <returns>
        <c>true</c> if there was something multiplexed for given <paramref name="key" />; <c>false</c> otherwise.</returns>
    </member>
    <member name="P:UtilPack.Multiplexer`2.KeysSnapshot">
      <summary>
            Gets a snapshot of all the keys of this multiplexer.
            </summary>
      <value>A snapshot of all the keys of this multiplexer.</value>
    </member>
    <member name="P:UtilPack.Multiplexer`2.ValuesSnapshot">
      <summary>
            Gets a snapshot of all the values of this multiplexer.
            </summary>
      <value>A snapshot of all the values of this multiplexer.</value>
    </member>
    <member name="P:UtilPack.Multiplexer`2.Snapshot">
      <summary>
            Gets a snapshot of multiplexer dictionary.
            </summary>
      <value>A snapshot of multiplexer dictionary.</value>
    </member>
    <member name="M:UtilPack.Multiplexer`2.Combine(`1,`1)">
      <summary>
            Subclasses should implement this method which will be used to combine existing and new value into one.
            </summary>
      <param name="existing">The currently existing value.</param>
      <param name="newValue">The new value to add to existing.</param>
      <returns>The combined value of <paramref name="existing" /> and <paramref name="newValue" /></returns>
    </member>
    <member name="M:UtilPack.Multiplexer`2.Remove(`1,`1)">
      <summary>
            Subclasses should implement this method which will be used to remove value from existing value combination.
            </summary>
      <param name="existing">The currently existing value.</param>
      <param name="removable">The value to remove.</param>
      <returns>The <paramref name="existing" /> value without <paramref name="removable" />.</returns>
    </member>
    <member name="T:UtilPack.NullableEqualityComparer`1">
      <summary>
            This class provides equality comparer functionality for nullable types.
            </summary>
      <typeparam name="T">The nullable type.</typeparam>
      <remarks>
            The <see cref="M:System.Object.Equals(System.Object)" /> implementation for nullable types works fine, however there is small overhead as value is boxed, and the <see cref="M:System.Object.Equals(System.Object)" /> method is invoked, resulting in more checks and unboxing.
            </remarks>
    </member>
    <member name="P:UtilPack.NullableEqualityComparer`1.DefaultComparer">
      <summary>
            Returns the equality comparer for nullable type <typeparamref name="T" /> which uses the default equality comparer when comparing actual values.
            </summary>
      <value>The equality comparer for nullable type <typeparamref name="T" /> which uses the default equality comparer when comparing actual values.</value>
    </member>
    <member name="M:UtilPack.NullableEqualityComparer`1.Equals(System.Nullable{`0},System.Nullable{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Tests equality for given nullables without creating an instance of this class.
            </summary>
      <param name="x">The first nullable.</param>
      <param name="y">The second nullable.</param>
      <param name="comparer">The optional comparer for non-null values.</param>
      <returns>
        <c>true</c> if both are null, or if both are non-null and their values equal; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.NullableEqualityComparer`1.GetHashCode(System.Nullable{`0},System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
      <summary>
            Calculates hash code for given nullable without creating an instance of this class.
            </summary>
      <param name="obj">The nullable.</param>
      <param name="comparer">The optional comparer for non-null values.</param>
      <param name="hashCodeForNoValue">The hash code for null value.</param>
      <returns>The hash code returned by <paramref name="comparer" /> if <paramref name="obj" /> is not <c>null</c>, otherwise <paramref name="hashCodeForNoValue" />.</returns>
    </member>
    <member name="M:UtilPack.NullableEqualityComparer`1.NewComparer(System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
      <summary>
            Returns a new equality comparer for nullable type <typeparamref name="T" /> which uses given equality comparer when comparing actual values, and returns given, optional, hash code for nullables with no value.
            </summary>
      <param name="itemComparer">The equality comparer to use when comparing non-null values.</param>
      <param name="noValueHashCode">The hash code to return for null values.</param>
      <returns>A new equality comparer for nullable type <typeparamref name="T" />.</returns>
    </member>
    <member name="T:UtilPack.NullableComparer`1">
      <summary>
            This class provides comparer functionality for nullable types.
            </summary>
      <typeparam name="T">The nullable type</typeparam>
    </member>
    <member name="P:UtilPack.NullableComparer`1.DefaultComparer">
      <summary>
            Returns the comparer for nullable type <typeparamref name="T" /> which uses the default comparer when comparing actual values.
            </summary>
      <value>The comparer for nullable type <typeparamref name="T" /> which uses the equality comparer when comparing actual values.</value>
      <remarks>
            If nullable with no value is passed to this comparer, it sorts nulls first.
            </remarks>
    </member>
    <member name="M:UtilPack.NullableComparer`1.NewComparer(System.Collections.Generic.IComparer{`0},System.Boolean)">
      <summary>
            Returns a new comparer for nullable type <typeparamref name="T" /> which uses given comparer when comparing actual values, and sorts nulls first or last.
            </summary>
      <param name="itemComparer">The optional comparer to use when comparing actual values. Default will be used if no comparer is supplied.</param>
      <param name="nullsFirst">Whether to sort null values first.</param>
      <returns>A new comparer for nullable type <typeparamref name="T" />.</returns>
      <remarks>
            In order for null-sorting to work, make sure your sorting algorithm passes also null values to the comparer returned by this method.
            </remarks>
    </member>
    <member name="M:UtilPack.NullableComparer`1.Compare(System.Nullable{`0},System.Nullable{`0},System.Collections.Generic.IComparer{`0},System.Boolean)">
      <summary>
            Compares two values without creating an instance of this class.
            </summary>
      <param name="x">The first nullable value.</param>
      <param name="y">The second nullable value.</param>
      <param name="itemComparer">The optional comparer to use when comparing actual values. Default will be used if no comparer is supplied.</param>
      <param name="nullsFirst">Whether to sort null values first.</param>
      <returns>negative value if <paramref name="x" /> is considered to be less than <paramref name="y" />, positive value if <paramref name="x" /> is considered to be greater than <paramref name="y" />, or <c>0</c> if <paramref name="x" /> and <paramref name="y" /> are considered to be equal.</returns>
    </member>
    <member name="T:UtilPack.ReferenceEqualityComparer`1">
      <summary>
            This class will perform reference equality matching on its target type.
            </summary>
      <typeparam name="T">The type of objects being compared for equality.</typeparam>
    </member>
    <member name="P:UtilPack.ReferenceEqualityComparer`1.ReferenceBasedComparer">
      <summary>
            Returns the reference-based equality comparer for <typeparamref name="T" />.
            </summary>
      <value>The reference-based equality comparer for <typeparamref name="T" />.</value>
      <remarks>The return value can be casted to <see cref="T:System.Collections.IEqualityComparer" />.</remarks>
    </member>
    <member name="T:UtilPack.ResizableArray`1">
      <summary>
            This is helper class to hold an array, which can be resized.
            Unlike <see cref="T:System.Collections.Generic.List`1" />, this class provides direct access to the array.
            </summary>
      <typeparam name="T">The type of elements in the array.</typeparam>
    </member>
    <member name="M:UtilPack.ResizableArray`1.#ctor(System.Int32,System.Int32,System.Boolean)">
      <summary>
            Creates a new <see cref="T:UtilPack.ResizableArray`1" /> with given initial size and maximum size.
            </summary>
      <param name="initialSize">The initial size of the array. If this is less than <c>0</c>, then the initial size of the array will be <c>0</c>.</param>
      <param name="maxLimit">The maximum limit. If this is less than <c>0</c>, then the array may grow indefinetly.</param>
      <param name="exponentialResize">Whether to resize array exponentially, that is, do all resizes by doubling array length.</param>
    </member>
    <member name="P:UtilPack.ResizableArray`1.CurrentMaxCapacity">
      <summary>
            Gets or sets the current array size.
            If setter gets value smaller than current array size, it does nothing.
            </summary>
      <remarks>
            Setter may grow the array, so that the array reference that the array acquired prior to calling this method may no longer reference the same array that is returned by <see cref="P:UtilPack.ResizableArray`1.Array" /> property after calling this method.
            </remarks>
    </member>
    <member name="P:UtilPack.ResizableArray`1.ExponentialResize">
      <summary>
            Gets or sets the resize strategy for this resizable array.
            </summary>
      <value>
            The resize strategy for this resizable array.
            </value>
      <remarks>
            When this is <c>true</c>, then array is grown by doubling previous length, until it is at least new size.
            Otherwise, array is grown by resizing array directly to new size.
            No matter what this value is, the new size will never be greater than <see cref="P:UtilPack.ResizableArray`1.MaximumSize" />.
            </remarks>
    </member>
    <member name="P:UtilPack.ResizableArray`1.MaximumSize">
      <summary>
            Gets the maximum size for this <see cref="T:UtilPack.ResizableArray`1" />, as specified in constructor.
            </summary>
    </member>
    <member name="P:UtilPack.ResizableArray`1.Array">
      <summary>
            Gets the reference to the current array of this <see cref="T:UtilPack.ResizableArray`1" />.
            </summary>
      <value>The reference to the current array of this <see cref="T:UtilPack.ResizableArray`1" />.</value>
      <remarks>
            Setting <see cref="P:UtilPack.ResizableArray`1.CurrentMaxCapacity" /> may cause this to return reference to different instance of the array.
            </remarks>
    </member>
    <member name="T:UtilPack.Equality`1">
      <summary>
            This is delegate used in equality comparisons when getting hash code is not required.
            </summary>
      <typeparam name="T">The type of items to compare.</typeparam>
      <param name="x">The first item.</param>
      <param name="y">The second item.</param>
      <returns>
        <c>true</c> if <paramref name="x" /> and <paramref name="y" /> are considered to be equal; <c>false</c> otherwise.</returns>
    </member>
    <member name="T:UtilPack.HashCode`1">
      <summary>
            This is delegate used in getting hash code, when equality is not required.
            </summary>
      <typeparam name="T">The type of items to get hash code of.</typeparam>
      <param name="obj">The item.</param>
      <returns>The hashcode for <paramref name="obj" />.</returns>
    </member>
    <member name="T:UtilPack.SequenceEqualityComparer`2">
      <summary>
            This class provides content-based equality comparing for sequences.
            </summary>
      <typeparam name="T">The type of the sequence.</typeparam>
      <typeparam name="U">The type of the elements of the sequence.</typeparam>
      <seealso cref="T:UtilPack.ArrayEqualityComparer`1" />
    </member>
    <member name="P:UtilPack.SequenceEqualityComparer`2.DefaultSequenceEqualityComparer">
      <summary>
            Returns the equality comparer for sequence <typeparamref name="T" /> which will use default equality comparer for the elements of the sequence.
            </summary>
      <value>The equality comparer for sequence <typeparamref name="T" /> which will use default equality comparer for the elements of the sequence.</value>
      <remarks>The return value can be casted to <see cref="T:System.Collections.IEqualityComparer" />.</remarks>
    </member>
    <member name="M:UtilPack.SequenceEqualityComparer`2.NewSequenceEqualsComparer(System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Creates a new equality comparer for sequence <typeparamref name="T" /> which will use the given equality comparer for the elements of the sequence.
            </summary>
      <param name="itemComparer">The equality comparer to use when comparing elements of the sequence.</param>
      <returns>A new equality comparer for sequence <typeparamref name="T" /> which will use the given equality comparer for the elements of the sequence.</returns>
      <remarks>The return value can be casted to <see cref="T:System.Collections.IEqualityComparer" />.</remarks>
    </member>
    <member name="M:UtilPack.SequenceEqualityComparer`2.Equals(`0,`0,System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Checks equality of given sequences without creating a new instance of this class.
            </summary>
      <param name="x">The first sequence. May be <c>null</c>.</param>
      <param name="y">The second sequence. May be <c>null</c>.</param>
      <param name="itemComparer">The optional equality comparer for items of the sequence. If <c>null</c>, the default will be used.</param>
      <returns>Whether two collections equal.</returns>
    </member>
    <member name="M:UtilPack.SequenceEqualityComparer`2.GetHashCode(`0,System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Calculates the hash code of given sequence without creating a new instance of this class.
            </summary>
      <param name="obj">The colleciton. May be <c>null</c>.</param>
      <param name="itemComparer">The optional equality comparer for items of the sequence. If <c>null</c>, the default will be used.</param>
      <returns>The hash code for given sequence.</returns>
    </member>
    <member name="M:UtilPack.SequenceEqualityComparer`2.SequenceEquality(`0,`0,UtilPack.Equality{`1})">
      <summary>
            Helper method to check whether two sequences are considered to be equal given optional equality comparer for items.
            </summary>
      <param name="x">The first sequence. May be <c>null</c>.</param>
      <param name="y">The second sequence. May be <c>null</c>.</param>
      <param name="equality">The optional equality callback for items. If not supplied, a default callback (the <see cref="M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)" /> method from <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> ) will be used.</param>
      <returns>
        <c>true</c> if both sequences are <c>null</c>, or both sequences are non null and have same amount and same items; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.SequenceEqualityComparer`2.SequenceHashCode(`0,UtilPack.HashCode{`1})">
      <summary>
            Helper method to calculate hash code for sequence.
            </summary>
      <param name="obj">The sequence. May be <c>null</c>.</param>
      <param name="hashCode">The optional hashcode calculation callback. If not supplied, a default callback (the <see cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)" /> method from <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> ) will be used.</param>
      <returns>The hash code for <paramref name="obj" />.</returns>
    </member>
    <member name="M:UtilPack.SequenceEqualityComparer`2.IsPermutation(`0,`0,System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Checks that sequence are each others permutation.
            That is, both are of same length, and all elements contained in one, are also contained in another.
            </summary>
      <param name="x">The first sequence.</param>
      <param name="y">The second sequence.</param>
      <param name="itemComparer">The optional equality comparer for items of the sequence. If <c>null</c>, the default will be used.</param>
      <returns>
        <c>true</c> if <paramref name="x" /> and <paramref name="y" /> are of same length and contain same elements.</returns>
    </member>
    <member name="T:UtilPack.AbstractSetEqualityComparer`2">
      <summary>
            This is abstract class for comparing sequences as sets, i.e. order of elements does not matter.
            </summary>
      <typeparam name="T">The type of set.</typeparam>
      <typeparam name="U">The type of elements in set.</typeparam>
    </member>
    <member name="M:UtilPack.AbstractSetEqualityComparer`2.Contains(`0,`1)">
      <summary>
            The subclasses should override this method for checking whether the given set contains given item.
            </summary>
      <param name="set">The set. Will never be <c>null</c>.</param>
      <param name="item">The item to check.</param>
      <returns>
        <c>true</c> if <paramref name="set" /> contains <paramref name="item" />; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.AbstractSetEqualityComparer`2.CheckSize(`0,`0)">
      <summary>
            The subclasses should override this method for checking whether two sets are of equal size.
            </summary>
      <param name="set1">The first set. Will never be <c>null</c>.</param>
      <param name="set2">The second set. Will never be <c>null</c>.</param>
      <returns>
        <c>true</c> if <paramref name="set1" /> is of same size as <paramref name="set2" />; <c>false</c> otherwise.</returns>
    </member>
    <member name="T:UtilPack.DictionaryEqualityComparer`2">
      <summary>
            This class provides a way to compare dictionaries by-value, i.e. checking that two dictionaries are of same size and that all items in one dictionary are same as in other dictionary.
            </summary>
      <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of values in the dictionary.</typeparam>
    </member>
    <member name="P:UtilPack.DictionaryEqualityComparer`2.DefaultEqualityComparer">
      <summary>
            Returns the equality comparer which will compare dictionaries by-value using default equality compare for type <typeparamref name="TValue" />.
            </summary>
      <value>The equality comparer which will compare dictionaries by-value using default equality compare for type <typeparamref name="TValue" />.</value>
    </member>
    <member name="M:UtilPack.DictionaryEqualityComparer`2.NewDictionaryEqualityComparer(System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Creates a new equality comparer for comparing dictionaries by-value with specified equality comparer for value type.
            </summary>
      <param name="valueComparer">The equality comparer for value type. If <c>null</c>, a default comparer will be used.</param>
      <returns>A new equality comparer for comparing dictionaries by-value with specified equality comparer for value type.</returns>
    </member>
    <member name="M:UtilPack.DictionaryEqualityComparer`2.Contains(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1})">
      <inheritdoc />
    </member>
    <member name="M:UtilPack.DictionaryEqualityComparer`2.CheckSize(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`0,`1})">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.SetEqualityComparer`1">
      <summary>
            This class provides a way to compare sets by-value, i.e. checking that two sets are of same size and that one set contains all elements as other set, and nothing more.
            </summary>
      <typeparam name="TValue">The type of elements in the set.</typeparam>
    </member>
    <member name="P:UtilPack.SetEqualityComparer`1.DefaultEqualityComparer">
      <summary>
            Returns the equality comparer for comparing sets by-value using the equality comparer specified for the set.
            </summary>
      <value>The equality comparer for comparing sets by-value using the equality comparer specified for the set.</value>
    </member>
    <member name="M:UtilPack.SetEqualityComparer`1.CheckSize(System.Collections.Generic.ISet{`0},System.Collections.Generic.ISet{`0})">
      <inheritdoc />
    </member>
    <member name="M:UtilPack.SetEqualityComparer`1.Contains(System.Collections.Generic.ISet{`0},`0)">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.ArrayEqualityComparer`1">
      <summary>
            This class provides content-based equality comparing for arrays. It is still possible to use <see cref="T:UtilPack.SequenceEqualityComparer`2" /> for arrays and have same result, but this class will be faster.
            </summary>
      <typeparam name="T">The type of the elements of the array.</typeparam>
      <seealso cref="T:UtilPack.SequenceEqualityComparer`2" />
      <remarks>
            This class can return correct equality comparers for jagged arrays, e.g. <c>Int[][][]</c>.
            </remarks>
    </member>
    <member name="P:UtilPack.ArrayEqualityComparer`1.DefaultArrayEqualityComparer">
      <summary>
            Returns the equality comparer for arrays with element type <typeparamref name="T" /> which will use default equality comparer for the elements of the array.
            </summary>
      <value>The equality comparer for arrays with element type <typeparamref name="T" /> which will use default equality comparer for the elements of the array.</value>
      <remarks>
            The comparer for items will be acquired by calling <see cref="M:UtilPack.ComparerFromFunctions.GetDefaultItemComparerForSomeSequence``1" />.
            </remarks>
    </member>
    <member name="M:UtilPack.ArrayEqualityComparer`1.NewArrayEqualityComparer(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new equality comparer for arrays with element type <typeparamref name="T" /> which will use the given equality comparer for the elements of the array.
            </summary>
      <param name="itemComparer">The equality comparer to use when comparing elements of the array.</param>
      <returns>A new equality comparer for arrays with element type <typeparamref name="T" /> which will use the given equality comparer for the elements of the array.</returns>
    </member>
    <member name="M:UtilPack.ArrayEqualityComparer`1.Equals(`0[],`0[],System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Checks equality of given collections without creating a new instance of this class.
            </summary>
      <param name="x">The first array. May be <c>null</c>.</param>
      <param name="y">The second array. May be <c>null</c>.</param>
      <param name="itemComparer">The optional equality comparer for items of the array. If <c>null</c>, the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used.</param>
      <returns>Whether two collections equal.</returns>
    </member>
    <member name="M:UtilPack.ArrayEqualityComparer`1.GetHashCode(`0[],System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Calculates the hash code of given array without creating a new instance of this class.
            </summary>
      <param name="obj">The colleciton. May be <c>null</c>.</param>
      <param name="itemComparer">The optional equality comparer for items of the array. If <c>null</c>, the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used.</param>
      <returns>The hash code for given array.</returns>
    </member>
    <member name="M:UtilPack.ArrayEqualityComparer`1.ArrayEquality(`0[],`0[],UtilPack.Equality{`0})">
      <summary>
            Helper method to check whether two arrays are considered to be equal given optional equality comparer for items.
            </summary>
      <param name="x">The first array. May be <c>null</c>.</param>
      <param name="y">The second array. May be <c>null</c>.</param>
      <param name="equality">The optional equality callback for items. If not supplied, a default callback (the <see cref="M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)" /> method from the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> ) will be used.</param>
      <returns>
        <c>true</c> if both arrays are <c>null</c>, or both arrays are non null and have same amount and same items; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.ArrayEqualityComparer`1.ArrayHashCode(`0[],UtilPack.HashCode{`0})">
      <summary>
            Helper method to calculate hash code for array.
            </summary>
      <param name="obj">The array. May be <c>null</c>.</param>
      <param name="hashCode">The optional hashcode calculation callback. If not supplied, a default callback (the <see cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)" /> method from the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> ) will be used.</param>
      <returns>The hash code for <paramref name="obj" />.</returns>
    </member>
    <member name="M:UtilPack.ArrayEqualityComparer`1.IsPermutation(`0[],`0[],System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Checks that arrays are each others permutation.
            That is, both are of same length, and all elements contained in one, are also contained in another.
            </summary>
      <param name="x">The first array.</param>
      <param name="y">The second array.</param>
      <param name="itemComparer">The optional equality comparer for items of the array. If <c>null</c>, the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used.</param>
      <returns>
        <c>true</c> if <paramref name="x" /> and <paramref name="y" /> are of same length and contain same elements.</returns>
      <remarks>
            This is slightly better performing than always building a new <see cref="T:System.Collections.Generic.HashSet`1" /> with given comparer and using <see cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" /> method.
            This method will check for reference equality for arrays, and that the arrays are of same length and contain at least two elements before building a set.
            </remarks>
    </member>
    <member name="T:UtilPack.CollectionEqualityComparer`2">
      <summary>
            This class provides content-based equality comparing for collections. It is still possible to use <see cref="T:UtilPack.SequenceEqualityComparer`2" /> for collections and have same result, but this class will be faster.
            </summary>
      <typeparam name="T">The type of collection, e.g. <see cref="T:System.Collections.Generic.IList`1" />.</typeparam>
      <typeparam name="U">The type of the elements of the collection.</typeparam>
      <seealso cref="T:UtilPack.SequenceEqualityComparer`2" />
    </member>
    <member name="P:UtilPack.CollectionEqualityComparer`2.DefaultCollectionEqualityComparer">
      <summary>
            Returns the equality comparer for collections with element type <typeparamref name="T" /> which will use default equality comparer for the elements of the array.
            </summary>
      <value>The equality comparer for collections with element type <typeparamref name="T" /> which will use default equality comparer for the elements of the array.</value>
      <remarks>
            The comparer for items will be acquired by calling <see cref="M:UtilPack.ComparerFromFunctions.GetDefaultItemComparerForSomeSequence``1" />.
            </remarks>
    </member>
    <member name="M:UtilPack.CollectionEqualityComparer`2.NewCollectionEqualityComparer(System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Creates a new equality comparer for collections with element type <typeparamref name="T" /> which will use the given equality comparer for the elements of the collection.
            </summary>
      <param name="itemComparer">The equality comparer to use when comparing elements of the collection. The <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used if this is <c>null</c>.</param>
      <returns>A new equality comparer for collections with element type <typeparamref name="T" /> which will use the given equality comparer for the elements of the collection.</returns>
    </member>
    <member name="M:UtilPack.CollectionEqualityComparer`2.Equals(`0,`0,System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Checks equality of given collections without creating a new instance of this class.
            </summary>
      <param name="x">The first collection. May be <c>null</c>.</param>
      <param name="y">The second collection. May be <c>null</c>.</param>
      <param name="itemComparer">The optional equality comparer for items of the collection. If <c>null</c>, the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used.</param>
      <returns>Whether two collections equal.</returns>
    </member>
    <member name="M:UtilPack.CollectionEqualityComparer`2.GetHashCode(`0,System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Calculates the hash code of given collection without creating a new instance of this class.
            </summary>
      <param name="obj">The colleciton. May be <c>null</c>.</param>
      <param name="itemComparer">The optional equality comparer for items of the collection. If <c>null</c>, the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used.</param>
      <returns>The hash code for given collection.</returns>
    </member>
    <member name="M:UtilPack.CollectionEqualityComparer`2.CollectionEquality(`0,`0,UtilPack.Equality{`1})">
      <summary>
            Helper method to check whether two collections are considered to be equal given optional equality comparer for items.
            </summary>
      <param name="x">The first collection. May be <c>null</c>.</param>
      <param name="y">The second collection. May be <c>null</c>.</param>
      <param name="equality">The optional equality callback for items. If not supplied, a default callback (the <see cref="M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)" /> method from <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> ) will be used.</param>
      <returns>
        <c>true</c> if both collections are <c>null</c>, or both collections are non null and have same amount and same items; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.CollectionEqualityComparer`2.CollectionHashCode(`0,UtilPack.HashCode{`1})">
      <summary>
            Calculates the hash code of given collection without creating a new instance of this class.
            </summary>
      <param name="obj">The collection. May be <c>null</c>.</param>
      <param name="hashCode">The optional equality comparer for items of the collection. If <c>null</c>, the default callback (the <see cref="M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)" /> method from <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used.</param>
      <returns>The hash code for given collection.</returns>
    </member>
    <member name="M:UtilPack.CollectionEqualityComparer`2.IsPermutation(`0,`0,System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Checks that collections are each others permutation.
            That is, the count of elements in both are the same, and all elements contained in one, are also contained in another.
            </summary>
      <param name="x">The first collection.</param>
      <param name="y">The second collection.</param>
      <param name="itemComparer">The optional equality comparer for items of the collection. If <c>null</c>, the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used.</param>
      <returns>
        <c>true</c> if <paramref name="x" /> and <paramref name="y" /> have same element count and contain same elements.</returns>
      <remarks>
            This is slightly better performing than just building a new <see cref="T:System.Collections.Generic.HashSet`1" /> with given comparer and using <see cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" /> method.
            This method will check for reference equality for collections, and that the collection element count is same and contain at least one element before building a set.
            </remarks>
    </member>
    <member name="T:UtilPack.ListEqualityComparer`2">
      <summary>
            This class provides content-based equality comparing for lists. It is still possible to use <see cref="T:UtilPack.SequenceEqualityComparer`2" /> or <see cref="T:UtilPack.CollectionEqualityComparer`2" /> for lists and have same result, but this class will be faster and will not use heap memory.
            </summary>
      <typeparam name="T">The type of list, e.g. <see cref="T:System.Collections.Generic.List`1" />.</typeparam>
      <typeparam name="U">The type of the elements of the list.</typeparam>
      <seealso cref="T:UtilPack.SequenceEqualityComparer`2" />
      <seealso cref="T:UtilPack.CollectionEqualityComparer`2" />
    </member>
    <member name="P:UtilPack.ListEqualityComparer`2.DefaultListEqualityComparer">
      <summary>
            Returns the equality comparer for lists with element type <typeparamref name="T" /> which will use default equality comparer for the elements of the array.
            </summary>
      <value>The equality comparer for lists with element type <typeparamref name="T" /> which will use default equality comparer for the elements of the array.</value>
      <remarks>
            The comparer for items will be acquired by calling <see cref="M:UtilPack.ComparerFromFunctions.GetDefaultItemComparerForSomeSequence``1" />.
            </remarks>
    </member>
    <member name="M:UtilPack.ListEqualityComparer`2.NewListEqualityComparer(System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Creates a new equality comparer for lists with element type <typeparamref name="T" /> which will use the given equality comparer for the elements of the list.
            </summary>
      <param name="itemComparer">The equality comparer to use when comparing elements of the list. The <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used if this is <c>null</c>.</param>
      <returns>A new equality comparer for lists with element type <typeparamref name="T" /> which will use the given equality comparer for the elements of the list.</returns>
    </member>
    <member name="M:UtilPack.ListEqualityComparer`2.Equals(`0,`0,System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Checks equality of given lists without creating a new instance of this class.
            </summary>
      <param name="x">The first list. May be <c>null</c>.</param>
      <param name="y">The second list. May be <c>null</c>.</param>
      <param name="itemComparer">The optional equality comparer for items of the list. If <c>null</c>, the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used.</param>
      <returns>Whether two lists equal.</returns>
    </member>
    <member name="M:UtilPack.ListEqualityComparer`2.GetHashCode(`0,System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Calculates the hash code of given list without creating a new instance of this class.
            </summary>
      <param name="obj">The list. May be <c>null</c>.</param>
      <param name="itemComparer">The optional equality comparer for items of the list. If <c>null</c>, the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used.</param>
      <returns>The hash code for given list.</returns>
    </member>
    <member name="M:UtilPack.ListEqualityComparer`2.ListEquality(`0,`0,UtilPack.Equality{`1})">
      <summary>
            Helper method to check whether two lists are considered to be equal given optional equality comparer for items.
            </summary>
      <param name="x">The first list. May be <c>null</c>.</param>
      <param name="y">The second list. May be <c>null</c>.</param>
      <param name="equality">The optional equality callback for items. If not supplied, a default callback (the <see cref="M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)" /> method from <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> ) will be used.</param>
      <returns>
        <c>true</c> if both lists are <c>null</c>, or both lists are non null and have same amount and same items; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:UtilPack.ListEqualityComparer`2.ListHashCode(`0,UtilPack.HashCode{`1})">
      <summary>
            Helper method to calculate hash code for list.
            </summary>
      <param name="obj">The list. May be <c>null</c>.</param>
      <param name="hashCode">The optional hashcode calculation callback. If not supplied, a default callback (the <see cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)" /> method from <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> ) will be used.</param>
      <returns>The hash code for <paramref name="obj" />.</returns>
    </member>
    <member name="M:UtilPack.ListEqualityComparer`2.IsPermutation(`0,`0,System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Checks that lists are each others permutation.
            That is, the count of elements in both are the same, and all elements contained in one, are also contained in another.
            </summary>
      <param name="x">The first list.</param>
      <param name="y">The second list.</param>
      <param name="itemComparer">The optional equality comparer for items of the list. If <c>null</c>, the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> will be used.</param>
      <returns>
        <c>true</c> if <paramref name="x" /> and <paramref name="y" /> have same element count and contain same elements.</returns>
      <remarks>
            This is slightly better performing than just building a new <see cref="T:System.Collections.Generic.HashSet`1" /> with given comparer and using <see cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" /> method.
            This method will check for reference equality for lists, and that the list element count is same and contain at least two elements before building a set.
            </remarks>
    </member>
    <member name="T:UtilPack.PotentiallyAsyncReaderLogic`2">
      <summary>
            This interface provides abstract way to read characters possibly asynchronously from some source (e.g. stream or <see cref="T:System.String" />).
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
      <typeparam name="TSource">The type of the source from which to read the next character.</typeparam>
    </member>
    <member name="M:UtilPack.PotentiallyAsyncReaderLogic`2.TryReadNextAsync(`1)">
      <summary>
            Tries to read next item from given <paramref name="source" />.
            </summary>
      <param name="source">The <typeparamref name="TSource" /> to read next item from.</param>
      <returns>A task which will return item read, also indicating whether more items are available.</returns>
    </member>
    <member name="M:UtilPack.PotentiallyAsyncReaderLogic`2.IsReadSuccessful(`0)">
      <summary>
            Returns value indicating whether read result returned from <see cref="M:UtilPack.PotentiallyAsyncReaderLogic`2.TryReadNextAsync(`1)" /> can be considered as successful read.
            </summary>
      <param name="readResult">The read result obtained from <see cref="M:UtilPack.PotentiallyAsyncReaderLogic`2.TryReadNextAsync(`1)" />.</param>
      <returns>
        <c>true</c> if read result can be considered as successful read; <c>false</c> otherwise.</returns>
    </member>
    <member name="T:UtilPack.ReadCompletedEventArgs">
      <summary>
            This interface acts as base interface for event args of <see cref="E:UtilPack.PotentiallyAsyncReaderObservable`1.ReadCompleted" />, and contains all the information that does not require any type arguments.
            </summary>
    </member>
    <member name="P:UtilPack.ReadCompletedEventArgs.Success">
      <summary>
            Gets the value indicating whether this read was successful.
            </summary>
      <value>The value indicating whether this read was successful.</value>
    </member>
    <member name="T:UtilPack.ReadCompletedEventArgs`1">
      <summary>
            This interface augments <see cref="T:UtilPack.ReadCompletedEventArgs" /> with read result information.
            </summary>
      <typeparam name="TValue">The type of the values produced by the reader.</typeparam>
    </member>
    <member name="P:UtilPack.ReadCompletedEventArgs`1.Result">
      <summary>
            Gets the read result.
            </summary>
      <value>The read result.</value>
    </member>
    <member name="T:UtilPack.ReadCompletedEventArgsImpl`1">
      <summary>
            This class provides default implementation of <see cref="T:UtilPack.ReadCompletedEventArgs`1" />.
            </summary>
    </member>
    <member name="M:UtilPack.ReadCompletedEventArgsImpl`1.#ctor(System.Boolean,`0)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.ReadCompletedEventArgsImpl`1" /> with given read information.
            </summary>
      <param name="success">Whether read operation was successful.</param>
      <param name="result">The result of the read operation.</param>
    </member>
    <member name="P:UtilPack.ReadCompletedEventArgsImpl`1.Success">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.ReadCompletedEventArgsImpl`1.Result">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.PotentiallyAsyncReaderObservable`1">
      <summary>
            This itnerface provides observability for <see cref="T:UtilPack.PotentiallyAsyncReader`1" /> and thus allows <c>out</c> covariance specification on the <typeparamref name="TValue" />.
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
    </member>
    <member name="E:UtilPack.PotentiallyAsyncReaderObservable`1.ReadCompleted">
      <summary>
            This event will be triggered after each read operation.
            </summary>
    </member>
    <member name="T:UtilPack.PotentiallyAsyncReader`1">
      <summary>
            This interface binds the source type parameter of <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" /> in order to provide read method without parameters.
            This interface is intended to be used as parameter type to methods instead of passing a pair of <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" /> and the source object.
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
    </member>
    <member name="M:UtilPack.PotentiallyAsyncReader`1.TryReadNextAsync">
      <summary>
        <see cref="M:UtilPack.PotentiallyAsyncReaderLogic`2.TryReadNextAsync(`1)" />.
            </summary>
      <returns>
        <see cref="M:UtilPack.PotentiallyAsyncReaderLogic`2.TryReadNextAsync(`1)" />.</returns>
    </member>
    <member name="T:UtilPack.PeekablePotentiallyAsyncReader`1">
      <summary>
            This interface augments <see cref="T:UtilPack.PotentiallyAsyncReader`1" /> with peekability.
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
    </member>
    <member name="M:UtilPack.PeekablePotentiallyAsyncReader`1.TryPeekAsync">
      <summary>
            Tries to peek the next value asynchronously.
            Subsequent calls to this method will use cached peeked value, until <see cref="M:UtilPack.PotentiallyAsyncReader`1.TryReadNextAsync" /> is called.
            </summary>
    </member>
    <member name="T:UtilPack.MemorizingPotentiallyAsyncReader`2">
      <summary>
            This interface augments <see cref="T:UtilPack.PotentiallyAsyncReader`1" /> with clearable buffer of past read values.
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
      <typeparam name="TBufferItem">The type of the items in buffer.</typeparam>
    </member>
    <member name="P:UtilPack.MemorizingPotentiallyAsyncReader`2.Buffer">
      <summary>
            This will become System.Span when it's available.
            </summary>
      <value>The current buffer span.</value>
    </member>
    <member name="P:UtilPack.MemorizingPotentiallyAsyncReader`2.BufferCount">
      <summary>
            Gets the amount of useable items in <see cref="P:UtilPack.MemorizingPotentiallyAsyncReader`2.Buffer" />.
            </summary>
      <value>The amount of useable items in <see cref="P:UtilPack.MemorizingPotentiallyAsyncReader`2.Buffer" />.</value>
    </member>
    <member name="M:UtilPack.MemorizingPotentiallyAsyncReader`2.ClearBuffer">
      <summary>
            Clears the current buffer.
            </summary>
    </member>
    <member name="M:UtilPack.MemorizingPotentiallyAsyncReader`2.EraseBufferSegment(System.Int32,System.Int32)">
      <summary>
            Erases a specific segment in buffer.
            When this method completes, the <see cref="P:UtilPack.MemorizingPotentiallyAsyncReader`2.BufferCount" /> will be decremented by <paramref name="count" />.
            </summary>
      <param name="firstDeletableIndex">The index of the first item to be deleted.</param>
      <param name="count">The amount of items to delete.</param>
      <remarks>
            This method will do nothing if parameters are invalid in some way (e.g. out of range).
            </remarks>
    </member>
    <member name="M:UtilPack.MemorizingPotentiallyAsyncReader`2.ForgetBufferedItems(System.Int32)">
      <summary>
            Moves read-mark so that next call to <see cref="M:UtilPack.PotentiallyAsyncReader`1.TryReadNextAsync" /> will return buffered item instead of reading from underlying source.
            </summary>
      <param name="amount">The amount of items to forget. Negative amounts signify "all currently memorized items".</param>
    </member>
    <member name="T:UtilPack.BoundPotentiallyAsyncReader`2">
      <summary>
            This class provides implementation for <see cref="T:UtilPack.PotentiallyAsyncReader`1" />.
            </summary>
    </member>
    <member name="M:UtilPack.BoundPotentiallyAsyncReader`2.#ctor(UtilPack.PotentiallyAsyncReaderLogic{`0,`1},`1)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.BoundPotentiallyAsyncReader`2" /> with given reader and source.
            </summary>
      <param name="reader">The <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" />.</param>
      <param name="source">The source for <paramref name="reader" />.</param>
      <exception cref="T:System.ArgumentNullException">If <paramref name="reader" /> is <c>null</c>.</exception>
    </member>
    <member name="P:UtilPack.BoundPotentiallyAsyncReader`2.Source">
      <summary>
            Gets the source of this reader.
            </summary>
      <value>The source of this reader.</value>
    </member>
    <member name="P:UtilPack.BoundPotentiallyAsyncReader`2.Reader">
      <summary>
            Gets the underlying reader.
            </summary>
      <value>The underlying reader.</value>
    </member>
    <member name="M:UtilPack.BoundPotentiallyAsyncReader`2.TryReadNextAsync">
      <summary>
        <see cref="M:UtilPack.PotentiallyAsyncReaderLogic`2.TryReadNextAsync(`1)" />.
            </summary>
      <returns>
        <see cref="M:UtilPack.PotentiallyAsyncReaderLogic`2.TryReadNextAsync(`1)" />.</returns>
    </member>
    <member name="E:UtilPack.BoundPotentiallyAsyncReader`2.ReadCompleted">
      <summary>
        <see cref="E:UtilPack.PotentiallyAsyncReaderObservable`1.ReadCompleted" />.
            </summary>
    </member>
    <member name="T:UtilPack.BoundPeekablePotentiallyAsyncReader`2">
      <summary>
            This class provides implementation for <see cref="M:UtilPack.PotentiallyAsyncReader`1.TryReadNextAsync" /> and <see cref="M:UtilPack.PeekablePotentiallyAsyncReader`1.TryPeekAsync" />.
            </summary>
    </member>
    <member name="M:UtilPack.BoundPeekablePotentiallyAsyncReader`2.#ctor(UtilPack.PotentiallyAsyncReaderLogic{`0,`1},`1)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.BoundPeekablePotentiallyAsyncReader`2" /> with given reader and source.
            </summary>
      <param name="reader">The <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" />.</param>
      <param name="source">The source for <paramref name="reader" />.</param>
      <exception cref="T:System.ArgumentNullException">If <paramref name="reader" /> is <c>null</c>.</exception>
    </member>
    <member name="P:UtilPack.BoundPeekablePotentiallyAsyncReader`2.Source">
      <summary>
            Gets the source of this reader.
            </summary>
      <value>The source of this reader.</value>
    </member>
    <member name="P:UtilPack.BoundPeekablePotentiallyAsyncReader`2.Reader">
      <summary>
            Gets the underlying reader.
            </summary>
      <value>The underlying reader.</value>
    </member>
    <member name="M:UtilPack.BoundPeekablePotentiallyAsyncReader`2.TryReadNextAsync">
      <summary>
        <see cref="M:UtilPack.PotentiallyAsyncReaderLogic`2.TryReadNextAsync(`1)" />.
            </summary>
      <returns>
        <see cref="M:UtilPack.PotentiallyAsyncReaderLogic`2.TryReadNextAsync(`1)" />.</returns>
    </member>
    <member name="M:UtilPack.BoundPeekablePotentiallyAsyncReader`2.TryPeekAsync">
      <summary>
        <see cref="M:UtilPack.PeekablePotentiallyAsyncReader`1.TryPeekAsync" />.
            </summary>
      <returns>
        <see cref="M:UtilPack.PeekablePotentiallyAsyncReader`1.TryPeekAsync" />.</returns>
    </member>
    <member name="E:UtilPack.BoundPeekablePotentiallyAsyncReader`2.ReadCompleted">
      <summary>
        <see cref="E:UtilPack.PotentiallyAsyncReaderObservable`1.ReadCompleted" />.
            </summary>
    </member>
    <member name="T:UtilPack.BoundMemorizingPotentiallyAsyncReader`3">
      <summary>
            This class implements <see cref="T:UtilPack.MemorizingPotentiallyAsyncReader`2" />.
            </summary>
      <typeparam name="TValue">The type of values this reader produces.</typeparam>
      <typeparam name="TBufferItem">The type of buffer items that this reader memorizes.</typeparam>
      <typeparam name="TSource">The type of source bound to this reader.</typeparam>
    </member>
    <member name="P:UtilPack.BoundMemorizingPotentiallyAsyncReader`3.Source">
      <summary>
            Gets the source of this reader.
            </summary>
      <value>The source of this reader.</value>
    </member>
    <member name="P:UtilPack.BoundMemorizingPotentiallyAsyncReader`3.Reader">
      <summary>
            Gets the underlying reader.
            </summary>
      <value>The underlying reader.</value>
    </member>
    <member name="M:UtilPack.BoundMemorizingPotentiallyAsyncReader`3.TryReadNextAsync">
      <summary>
        <see cref="M:UtilPack.PotentiallyAsyncReaderLogic`2.TryReadNextAsync(`1)" />.
            </summary>
      <returns>
        <see cref="M:UtilPack.PotentiallyAsyncReaderLogic`2.TryReadNextAsync(`1)" />.</returns>
    </member>
    <member name="M:UtilPack.BoundMemorizingPotentiallyAsyncReader`3.TryPeekAsync">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.BoundMemorizingPotentiallyAsyncReader`3.Buffer">
      <summary>
            This will become System.Span when it's available.
            </summary>
      <value>The current buffer span.</value>
    </member>
    <member name="P:UtilPack.BoundMemorizingPotentiallyAsyncReader`3.BufferCount">
      <summary>
            Gets the amount of useable items in <see cref="P:UtilPack.BoundMemorizingPotentiallyAsyncReader`3.Buffer" />.
            </summary>
      <value>The amount of useable items in <see cref="P:UtilPack.BoundMemorizingPotentiallyAsyncReader`3.Buffer" />.</value>
    </member>
    <member name="M:UtilPack.BoundMemorizingPotentiallyAsyncReader`3.ClearBuffer">
      <summary>
            Clears the current buffer.
            </summary>
    </member>
    <member name="M:UtilPack.BoundMemorizingPotentiallyAsyncReader`3.EraseBufferSegment(System.Int32,System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:UtilPack.BoundMemorizingPotentiallyAsyncReader`3.ForgetBufferedItems(System.Int32)">
      <inheritdoc />
    </member>
    <member name="E:UtilPack.BoundMemorizingPotentiallyAsyncReader`3.ReadCompleted">
      <summary>
        <see cref="E:UtilPack.PotentiallyAsyncReaderObservable`1.ReadCompleted" />.
            </summary>
    </member>
    <member name="T:UtilPack.StringIndex">
      <summary>
            This class represents incrementable index in a string.
            </summary>
    </member>
    <member name="M:UtilPack.StringIndex.#ctor(System.String,System.Int32,System.Int32)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.StringIndex" /> with given string and optional range.
            </summary>
      <param name="str">The string.</param>
      <param name="offset">The starting index.</param>
      <param name="count">The amount of characters to include to be indexed. Negative values are interpreted as "the rest starting from <paramref name="offset" />.</param>
      <exception cref="T:System.ArgumentNullException">If <paramref name="str" /> is <c>null</c>.</exception>
    </member>
    <member name="P:UtilPack.StringIndex.String">
      <summary>
            Gets the full string as given to this <see cref="T:UtilPack.StringIndex" />.
            </summary>
      <value>The full string as given to this <see cref="T:UtilPack.StringIndex" />.</value>
    </member>
    <member name="P:UtilPack.StringIndex.CurrentIndex">
      <summary>
            Gets the current index to the string of this <see cref="T:UtilPack.StringIndex" />.
            </summary>
      <value>The current index to the string of this <see cref="T:UtilPack.StringIndex" />.</value>
    </member>
    <member name="M:UtilPack.StringIndex.TryGetNextIndex(System.Int32@)">
      <summary>
            Tries to get index for the next character.
            </summary>
      <param name="idx">This parameter will hold the index.</param>
      <returns>
        <c>true</c> if <paramref name="idx" /> will fall within acceptable range; <c>false</c> otherwise.</returns>
    </member>
    <member name="T:UtilPack.StringCharacterReaderLogic">
      <summary>
            This class implements <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" /> to provide pseudo-asynchronous character reading over a <see cref="T:UtilPack.StringIndex" />.
            </summary>
    </member>
    <member name="F:UtilPack.StringCharacterReaderLogic.Instance">
      <summary>
            Gets the default, stateless instance.
            </summary>
    </member>
    <member name="M:UtilPack.StringCharacterReaderLogic.TryReadNextAsync(UtilPack.StringIndex)">
      <inheritdoc />
    </member>
    <member name="M:UtilPack.StringCharacterReaderLogic.IsReadSuccessful(System.Nullable{System.Char})">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.ReaderFactory">
      <summary>
            This class provides method to easily create various readers, e.g. <see cref="T:UtilPack.BoundPeekablePotentiallyAsyncReader`2" /> instances.
            </summary>
    </member>
    <member name="M:UtilPack.ReaderFactory.NewNullablePeekableValueReader``2(UtilPack.PotentiallyAsyncReaderLogic{System.Nullable{``0},``1},``1)">
      <summary>
            Creates new <see cref="T:UtilPack.BoundPeekablePotentiallyAsyncReader`2" /> which reads nullable struct values.
            </summary>
      <param name="reader">The underlying <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" />.</param>
      <param name="source">The source to use with <paramref name="reader" />.</param>
      <typeparam name="TValue">The struct type to read.</typeparam>
      <typeparam name="TSource">The source from which to read.</typeparam>
      <returns>A new <see cref="T:UtilPack.BoundPeekablePotentiallyAsyncReader`2" /> which reads nullable struct values.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="reader" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.ReaderFactory.NewNullableMemorizingValueReader``2(UtilPack.PotentiallyAsyncReaderLogic{System.Nullable{``0},``1},``1,UtilPack.ResizableArray{``0})">
      <summary>
            Creates new <see cref="T:UtilPack.BoundMemorizingPotentiallyAsyncReader`3" /> which reads nullable struct values.
            </summary>
      <param name="reader">The underlying <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" />.</param>
      <param name="source">The source to use with <paramref name="reader" />.</param>
      <param name="buffer">The optional existing buffer to use.</param>
      <typeparam name="TValue">The struct type to read.</typeparam>
      <typeparam name="TSource">The source from which to read.</typeparam>
      <returns>A new <see cref="T:UtilPack.BoundMemorizingPotentiallyAsyncReader`3" /> which reads nullable struct values.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="reader" /> is <c>null</c>.</exception>
    </member>
    <member name="T:UtilPack.StreamCharacterReaderLogic">
      <summary>
            This class provides functionality to read characters from <see cref="T:UtilPack.StreamReaderWithResizableBuffer" />.
            </summary>
    </member>
    <member name="M:UtilPack.StreamCharacterReaderLogic.#ctor(UtilPack.IEncodingInfo)">
      <summary>
            Creates new instance of <see cref="T:UtilPack.StreamCharacterReaderLogic" /> with given <see cref="T:UtilPack.IEncodingInfo" />.
            </summary>
      <param name="encodingInfo">The <see cref="T:UtilPack.IEncodingInfo" />.</param>
      <exception cref="T:System.ArgumentNullException">If <paramref name="encodingInfo" /> is <c>null</c>.</exception>
    </member>
    <member name="P:UtilPack.StreamCharacterReaderLogic.Encoding">
      <summary>
            Gets the <see cref="T:UtilPack.IEncodingInfo" /> of this <see cref="T:UtilPack.StreamCharacterReaderLogic" />.
            </summary>
      <value>The <see cref="T:UtilPack.IEncodingInfo" /> of this <see cref="T:UtilPack.StreamCharacterReaderLogic" />.</value>
    </member>
    <member name="M:UtilPack.StreamCharacterReaderLogic.TryReadNextAsync(UtilPack.StreamReaderWithResizableBuffer)">
      <summary>
            Tries to read next character from given <paramref name="stream" />.
            </summary>
      <param name="stream">The <see cref="T:UtilPack.StreamReaderWithResizableBuffer" /> to read character from. The <see cref="M:UtilPack.StreamReaderWithResizableBuffer.TryReadMoreAsync(System.Int32)" /> method will be used.</param>
      <returns>A task which will return character read, or <c>null</c> if no more characters could be read from <paramref name="stream" />.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="stream" /> is <c>null</c>.</exception>
      <exception cref="T:System.InvalidOperationException">If this reader is currently busy with another read operation.</exception>
    </member>
    <member name="M:UtilPack.StreamCharacterReaderLogic.IsReadSuccessful(System.Nullable{System.Char})">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.PotentiallyAsyncWriterLogic`2">
      <summary>
            This interface provides API for functionality which serializes some value to some sink, potentially asynchronously.
            </summary>
      <typeparam name="TValue">The type of the values to serialize.</typeparam>
      <typeparam name="TSink">The type of sink where serialized data is stored to.</typeparam>
    </member>
    <member name="M:UtilPack.PotentiallyAsyncWriterLogic`2.TryWriteAsync(`0,`1)">
      <summary>
            Tries to write the value to serialization sink.
            </summary>
      <param name="value">The value to serialize.</param>
      <param name="sink">The sink to write serialized data to.</param>
      <returns>Task which returns amount of units serialized to <paramref name="sink" />.</returns>
    </member>
    <member name="T:UtilPack.StreamCharacterWriterLogic">
      <summary>
            This class implements <see cref="T:UtilPack.PotentiallyAsyncWriterLogic`2" /> to serialize characters to byte stream with given encoding.
            </summary>
    </member>
    <member name="M:UtilPack.StreamCharacterWriterLogic.#ctor(UtilPack.IEncodingInfo,System.Int32)">
      <summary>
            Creates new instance of <see cref="T:UtilPack.StreamCharacterWriterLogic" /> with given parameters.
            </summary>
      <param name="encoding">The <see cref="T:UtilPack.IEncodingInfo" /> that will be used to encode characters.</param>
      <param name="maxBufferSize">The maximum allowed buffer size that any <see cref="T:UtilPack.StreamWriterWithResizableBuffer" /> will be allowed to have.</param>
    </member>
    <member name="M:UtilPack.StreamCharacterWriterLogic.TryWriteAsync(System.Collections.Generic.IEnumerable{System.Char},UtilPack.StreamWriterWithResizableBuffer)">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.PotentiallyAsyncWriter`1">
      <summary>
            This interface binds together <see cref="T:UtilPack.PotentiallyAsyncWriterLogic`2" /> and some sink, without exposing the sink, and allows <c>in</c> contravariance specification for <typeparamref name="TValue" />.
            </summary>
      <typeparam name="TValue">The type of values that this writer can write.</typeparam>
      <seealso cref="T:UtilPack.PotentiallyAsyncWriterObservable`1" />
      <seealso cref="T:UtilPack.PotentiallyAsyncWriterAndObservable`1" />
    </member>
    <member name="M:UtilPack.PotentiallyAsyncWriter`1.TryWriteAsync(`0)">
      <summary>
            This method will try to write given value to the sink bound to this <see cref="T:UtilPack.PotentiallyAsyncWriter`1" />.
            </summary>
      <param name="value">The value to serialize.</param>
      <returns>Task which will return amount of units written to sink.</returns>
    </member>
    <member name="T:UtilPack.PotentiallyAsyncWriterObservable`1">
      <summary>
            This interface exposes event which is raised after each call to <see cref="M:UtilPack.PotentiallyAsyncWriter`1.TryWriteAsync(`0)" />, and allows <c>out</c> covariance specification for <typeparamref name="TValue" />.
            </summary>
      <typeparam name="TValue">The type of values that this writer can write.</typeparam>
      <seealso cref="T:UtilPack.PotentiallyAsyncWriter`1" />
      <seealso cref="T:UtilPack.PotentiallyAsyncWriterAndObservable`1" />
    </member>
    <member name="E:UtilPack.PotentiallyAsyncWriterObservable`1.WriteCompleted">
      <summary>
            This event will be triggered after each call to <see cref="M:UtilPack.PotentiallyAsyncWriter`1.TryWriteAsync(`0)" />.
            </summary>
    </member>
    <member name="T:UtilPack.PotentiallyAsyncWriterAndObservable`1">
      <summary>
            This interface binds together <see cref="T:UtilPack.PotentiallyAsyncWriter`1" /> and <see cref="T:UtilPack.PotentiallyAsyncWriterObservable`1" />, but loses any variance specifications to <typeparamref name="TValue" /> in doing so.
            </summary>
      <typeparam name="TValue">The type of values that this writer can write.</typeparam>
    </member>
    <member name="T:UtilPack.WriteCompletedEventArgs">
      <summary>
            This is base interface for <see cref="E:UtilPack.PotentiallyAsyncWriterObservable`1.WriteCompleted" /> containing information that does not require any type parameters.
            </summary>
    </member>
    <member name="P:UtilPack.WriteCompletedEventArgs.UnitsWritten">
      <summary>
            Gets the amount of units written to sink.
            </summary>
      <value>The amount of units written to sink.</value>
    </member>
    <member name="T:UtilPack.WriteCompletedEventArgs`1">
      <summary>
            This interface augments <see cref="T:UtilPack.WriteCompletedEventArgs" /> with value type parameter.
            </summary>
      <typeparam name="TValue">The type of values that can be written.</typeparam>
    </member>
    <member name="P:UtilPack.WriteCompletedEventArgs`1.Value">
      <summary>
            Gets the value that was written to sink.
            </summary>
      <value>The value that was written to sink.</value>
    </member>
    <member name="T:UtilPack.WriteCompletedEventArgsImpl`1">
      <summary>
            This class provides default implementation for <see cref="T:UtilPack.WriteCompletedEventArgs`1" />.
            </summary>
      <typeparam name="TValue">The type of values that can be written.</typeparam>
    </member>
    <member name="M:UtilPack.WriteCompletedEventArgsImpl`1.#ctor(System.Int32,`0)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.WriteCompletedEventArgsImpl`1" /> with given parameters.
            </summary>
      <param name="unitsWritten">The amount of units written in this write.</param>
      <param name="value">The value written to sink.</param>
    </member>
    <member name="P:UtilPack.WriteCompletedEventArgsImpl`1.UnitsWritten">
      <summary>
            Gets the amount of units written to sink.
            </summary>
      <value>The amount of units written to sink.</value>
    </member>
    <member name="P:UtilPack.WriteCompletedEventArgsImpl`1.Value">
      <summary>
            Gets the value that was written to sink.
            </summary>
      <value>The value that was written to sink.</value>
    </member>
    <member name="T:UtilPack.TransformablePotentiallyAsyncWriter`3">
      <summary>
            This class implements <see cref="T:UtilPack.PotentiallyAsyncWriterAndObservable`1" /> with callback which transforms values to be serialized into values understood by underlying <see cref="T:UtilPack.PotentiallyAsyncWriterLogic`2" />.
            </summary>
      <typeparam name="TValue">The type of values to be serialized.</typeparam>
      <typeparam name="TSink">The type of serialization sink supported by <see cref="T:UtilPack.PotentiallyAsyncWriterLogic`2" />.</typeparam>
      <typeparam name="TTransformed">The type of values understood by <see cref="T:UtilPack.PotentiallyAsyncWriterLogic`2" />, which values of type <typeparamref name="TValue" /> can be transformed to.</typeparam>
    </member>
    <member name="M:UtilPack.TransformablePotentiallyAsyncWriter`3.TryWriteAsync(`0)">
      <inheritdoc />
    </member>
    <member name="E:UtilPack.TransformablePotentiallyAsyncWriter`3.WriteCompleted">
      <inheritdoc />
    </member>
    <member name="T:UtilPack.WriterFactory">
      <summary>
            This class provides methods to create instances of various <see cref="T:UtilPack.PotentiallyAsyncWriterAndObservable`1" />.
            </summary>
    </member>
    <member name="M:UtilPack.WriterFactory.CreateTransformableWriter``3(UtilPack.PotentiallyAsyncWriterLogic{``2,``1},``1,System.Func{``0,``2})">
      <summary>
            Creates new <see cref="T:UtilPack.PotentiallyAsyncWriterAndObservable`1" /> which transforms the values given to <see cref="M:UtilPack.PotentiallyAsyncWriter`1.TryWriteAsync(`0)" /> to values understood by underlying <see cref="T:UtilPack.PotentiallyAsyncWriterLogic`2" />.
            </summary>
      <param name="writer">The underlying <see cref="T:UtilPack.PotentiallyAsyncWriterLogic`2" /> logic.</param>
      <param name="sink">The sink to write to.</param>
      <param name="transformer">The callback which should transform values of <typeparamref name="TValue" /> into values of type <typeparamref name="TTransformed" />, understood by <paramref name="writer" />.</param>
      <typeparam name="TValue">Type of values to serialize.</typeparam>
      <typeparam name="TSink">Type of sink to serialize to.</typeparam>
      <typeparam name="TTransformed">The type of values understood by <paramref name="writer" />.</typeparam>
    </member>
    <member name="T:UtilPack.AbstractStreamWithResizableBuffer">
      <summary>
            This is base interface for objects which encapsulate a <see cref="T:System.IO.Stream" /> along with growable buffer.
            </summary>
    </member>
    <member name="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer">
      <summary>
            Do not cache instances of the return value of this property!
            Once System.Span &amp; Co will arrive, this property will become System.Span or maybe System.Buffer or maybe System.Memory.
            </summary>
    </member>
    <member name="P:UtilPack.AbstractStreamWithResizableBuffer.CancellationToken">
      <summary>
            Gets the <see cref="T:System.Threading.CancellationToken" /> used for async operations of the underlying <see cref="T:System.IO.Stream" />.
            </summary>
      <value>The <see cref="T:System.Threading.CancellationToken" /> used for async operations of the underlying <see cref="T:System.IO.Stream" />.</value>
    </member>
    <member name="T:UtilPack.StreamReaderWithResizableBuffer">
      <summary>
            This interface provides methods to read from the underlying <see cref="T:System.IO.Stream" />.
            The basic principle is that there is a marker index (accessible by <see cref="P:UtilPack.StreamReaderWithResizableBuffer.ReadBytesCount" />), which can be expanded by <see cref="M:UtilPack.StreamReaderWithResizableBuffer.TryReadMoreAsync(System.Int32)" /> method.
            The <see cref="M:UtilPack.StreamReaderWithResizableBuffer.TryReadAsync(System.Int32)" /> method will discard any bytes previously read into buffer and read the next bytes starting from <c>0</c> index.
            The amount of useable bytes of <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" /> will always be <see cref="P:UtilPack.StreamReaderWithResizableBuffer.ReadBytesCount" />, starting from <c>0</c> index of <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" />.
            </summary>
      <remarks>
            The default implementation <see cref="T:UtilPack.StreamReaderWithResizableBufferImpl" /> will read underlying <see cref="T:System.IO.Stream" /> in chunks, therefore the return types of <see cref="M:UtilPack.StreamReaderWithResizableBuffer.TryReadAsync(System.Int32)" /> and <see cref="M:UtilPack.StreamReaderWithResizableBuffer.TryReadMoreAsync(System.Int32)" /> are <see cref="T:System.Threading.Tasks.ValueTask`1" />, since asynchrony will happen only when it is actually needed to read from stream.
            <see cref="T:UtilPack.StreamFactory" /> class provides methods to create objects implementing this interface.
            </remarks>
    </member>
    <member name="M:UtilPack.StreamReaderWithResizableBuffer.TryReadAsync(System.Int32)">
      <summary>
            Discards previously read bytes that have been read into buffer using <see cref="M:UtilPack.StreamReaderWithResizableBuffer.EraseReadBytesFromBuffer" />, and tries to read more bytes from the stream.
            After the returned task completes, the following condition will apply: <c>0 ≤ </c><see cref="P:UtilPack.StreamReaderWithResizableBuffer.ReadBytesCount" /><c> ≤ </c><paramref name="amount" />.
            </summary>
      <param name="amount">The amount of bytes to read.</param>
      <returns>The task which will indicate whether given amount of bytes has been read.</returns>
      <exception cref="T:System.InvalidOperationException">If this stream reader is currently unusable (concurrent read or usage of nested buffer created by <see cref="M:UtilPack.StreamReaderWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)" />).</exception>
    </member>
    <member name="M:UtilPack.StreamReaderWithResizableBuffer.TryReadMoreAsync(System.Int32)">
      <summary>
            Tries to read more bytes from the stream into buffer, placing them after current <see cref="P:UtilPack.StreamReaderWithResizableBuffer.ReadBytesCount" />.
            After the returned task completes, the following condition will apply (x = value of <see cref="P:UtilPack.StreamReaderWithResizableBuffer.ReadBytesCount" /> when this method was called):<c>x ≤ </c><see cref="P:UtilPack.StreamReaderWithResizableBuffer.ReadBytesCount" /><c> ≤ x + </c><paramref name="amount" />.
            </summary>
      <param name="amount">The amount of bytes to read.</param>
      <returns>The task which will indicate whether given amount of bytes has been read.</returns>
      <exception cref="T:System.InvalidOperationException">If this stream reader is currently unusable (concurrent read or usage of nested buffer created by <see cref="M:UtilPack.StreamReaderWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)" />).</exception>
    </member>
    <member name="M:UtilPack.StreamReaderWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)">
      <summary>
            Creates <see cref="T:UtilPack.InnerStreamReaderWithResizableBufferAndLimitedSize" /> to be used to read the next <paramref name="byteCount" /> bytes.
            If creation is successful, the read bytes will be erased using <see cref="M:UtilPack.StreamReaderWithResizableBuffer.EraseReadBytesFromBuffer" /> before returning the <see cref="T:UtilPack.InnerStreamReaderWithResizableBufferAndLimitedSize" />.
            This <see cref="T:UtilPack.StreamReaderWithResizableBuffer" /> will become unusable until the <see cref="M:System.IDisposable.Dispose" /> method is called on returned <see cref="T:UtilPack.InnerStreamReaderWithResizableBufferAndLimitedSize" />.
            </summary>
      <param name="byteCount">The amount of bytes to reserve to returned <see cref="T:UtilPack.InnerStreamReaderWithResizableBufferAndLimitedSize" />.</param>
      <returns>The <see cref="T:UtilPack.InnerStreamReaderWithResizableBufferAndLimitedSize" /> with <c>0 ≤ </c><see cref="P:UtilPack.LimitedSizeInfo.TotalByteCount" /><c> ≤ </c><paramref name="byteCount" />.</returns>
      <exception cref="T:System.InvalidOperationException">If this stream reader is currently unusable (concurrent read or usage of nested buffer created by <see cref="M:UtilPack.StreamReaderWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)" />).</exception>
    </member>
    <member name="P:UtilPack.StreamReaderWithResizableBuffer.ReadBytesCount">
      <summary>
            Gets the amount of useable bytes in <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" />.
            </summary>
      <value>The amount of useable bytes in <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" />.</value>
    </member>
    <member name="M:UtilPack.StreamReaderWithResizableBuffer.EraseReadBytesFromBuffer">
      <summary>
            Erases all read bytes.
            When this method completes, the <see cref="P:UtilPack.StreamReaderWithResizableBuffer.ReadBytesCount" /> will be <c>0</c>.
            </summary>
      <exception cref="T:System.InvalidOperationException">If this stream reader is currently unusable (concurrent read or usage of nested buffer created by <see cref="M:UtilPack.StreamReaderWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)" />).</exception>
    </member>
    <member name="M:UtilPack.StreamReaderWithResizableBuffer.EraseReadBufferSegment(System.Int32,System.Int32)">
      <summary>
            Erases a specific segment in read bytes.
            When this method completes, the <see cref="P:UtilPack.StreamReaderWithResizableBuffer.ReadBytesCount" /> will be decremented by <paramref name="count" />.
            </summary>
      <param name="firstDeletableByteIndex">The index of the first byte to be deleted.</param>
      <param name="count">The amount of bytes to delete.</param>
      <exception cref="T:System.InvalidOperationException">If this stream reader is currently unusable (concurrent read or usage of nested buffer created by <see cref="M:UtilPack.StreamReaderWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)" />).</exception>
      <remarks>
            This method will do nothing if parameters are invalid in some way (e.g. out of range).
            </remarks>
    </member>
    <member name="M:UtilPack.StreamReaderWithResizableBuffer.UnreadBytes(System.Int32)">
      <summary>
            Moves read marker backwards without erasing bytes.
            When this method completes, the <see cref="P:UtilPack.StreamReaderWithResizableBuffer.ReadBytesCount" /> will be decremented by <paramref name="amount" />, or will be <c>0</c> if <paramref name="amount" /> is negative.
            </summary>
      <param name="amount">The amount of bytes to move marker backwards. If negative, then the marker will be moved to start.</param>
      <exception cref="T:System.InvalidOperationException">If this stream reader is currently unusable (concurrent read or usage of nested buffer created by <see cref="M:UtilPack.StreamReaderWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)" />).</exception>
    </member>
    <member name="P:UtilPack.StreamReaderWithResizableBuffer.ChunkSize">
      <summary>
            Gets amount of bytes that is used as starting point when determining how many bytes to read from underlying stream for one call of <see cref="M:UtilPack.StreamReaderWithResizableBuffer.TryReadAsync(System.Int32)" /> or <see cref="M:UtilPack.StreamReaderWithResizableBuffer.TryReadMoreAsync(System.Int32)" />.
            </summary>
      <value>The amount of bytes that is used as starting point when determining how many bytes to read from underlying stream.</value>
    </member>
    <member name="T:UtilPack.LimitedSizeInfo">
      <summary>
            This is common interface for stream readers and writers with limited size, <see cref="T:UtilPack.StreamReaderWithResizableBufferAndLimitedSize" /> and <see cref="T:UtilPack.StreamWriterWithResizableBufferAndLimitedSize" />.
            </summary>
    </member>
    <member name="P:UtilPack.LimitedSizeInfo.TotalByteCount">
      <summary>
            Gets the initial byte count.
            </summary>
      <value>The initial byte count.</value>
    </member>
    <member name="P:UtilPack.LimitedSizeInfo.BytesLeft">
      <summary>
            Gets the value indicating how many bytes are left for operations of this stream reader or writer.
            </summary>
      <value>The value indicating how many bytes are left for operations of this stream reader or writer.</value>
    </member>
    <member name="T:UtilPack.StreamReaderWithResizableBufferAndLimitedSize">
      <summary>
            This interface further specializes <see cref="T:UtilPack.StreamReaderWithResizableBuffer" /> introducing limitation on how many bytes can be read from the underlying <see cref="T:System.IO.Stream" />.
            </summary>
      <remarks>
        <see cref="T:UtilPack.StreamFactory" /> class provides methods to create objects implementing this interface.
            </remarks>
    </member>
    <member name="T:UtilPack.InnerStreamReaderWithResizableBufferAndLimitedSize">
      <summary>
            This interface augments <see cref="T:UtilPack.StreamReaderWithResizableBufferAndLimitedSize" /> interface with <see cref="M:System.IDisposable.Dispose" /> method from <see cref="T:System.IDisposable" />.
            By calling the <see cref="M:System.IDisposable.Dispose" /> method, the <see cref="T:UtilPack.StreamReaderWithResizableBuffer" /> which created this <see cref="T:UtilPack.InnerStreamReaderWithResizableBufferAndLimitedSize" /> will become useable again.
            </summary>
    </member>
    <member name="T:UtilPack.StreamWriterWithResizableBuffer">
      <summary>
            This interface provides methods to write to the underlying <see cref="T:System.IO.Stream" />.
            The buffer segments are reserved using <see cref="M:UtilPack.StreamWriterWithResizableBuffer.ReserveBufferSegment(System.Int32)" /> method, or bytes can appended to buffer right awayt with <see cref="M:E_UtilPack.AppendToBytes(UtilPack.StreamWriterWithResizableBuffer,System.Int32,System.Action{System.Byte[],System.Int32,System.Int32})" /> helper method. Once appended to buffer, the bytes are written to underlying stream using <see cref="M:UtilPack.StreamWriterWithResizableBuffer.FlushAsync" /> method.
            </summary>
      <remarks>
        <see cref="T:UtilPack.StreamFactory" /> class provides methods to create objects implementing this interface.
            </remarks>
    </member>
    <member name="M:UtilPack.StreamWriterWithResizableBuffer.ReserveBufferSegment(System.Int32)">
      <summary>
            This method tries to grow the <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" /> by given <paramref name="count" />, and returns the range that it succeeded to reserve.
            </summary>
      <param name="count">The amount of bytes to reserve.</param>
      <returns>The range information about actually reserved segment.</returns>
      <exception cref="T:System.InvalidOperationException">If this stream writer is currently unusable (concurrent write or usage of nested buffer created by <see cref="M:UtilPack.StreamWriterWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)" />).</exception>
    </member>
    <member name="M:UtilPack.StreamWriterWithResizableBuffer.UnreserveBufferSegment(System.Int32)">
      <summary>
            This method marks the given amount of bytes as free at the end of the buffer.
            </summary>
      <param name="count">The amount of bytes to free up. Negative values are treated as freeing up all of the buffer.</param>
      <exception cref="T:System.InvalidOperationException">If this stream writer is currently unusable (concurrent write or usage of nested buffer created by <see cref="M:UtilPack.StreamWriterWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)" />).</exception>
    </member>
    <member name="M:UtilPack.StreamWriterWithResizableBuffer.FlushAsync">
      <summary>
            This method asynchronously flushes the buffer contents to underlying <see cref="T:System.IO.Stream" />.
            </summary>
      <returns>The task which returns amount of bytes actually written to underlying <see cref="T:System.IO.Stream" />.</returns>
      <exception cref="T:System.InvalidOperationException">If this stream writer is currently unusable (concurrent write or usage of nested buffer created by <see cref="M:UtilPack.StreamWriterWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)" />).</exception>
    </member>
    <member name="P:UtilPack.StreamWriterWithResizableBuffer.ReservedBufferCount">
      <summary>
            Returns the current amount of reserved bytes in this <see cref="T:UtilPack.StreamWriterWithResizableBuffer" />.
            </summary>
      <value>The current amount of reserved bytes in this <see cref="T:UtilPack.StreamWriterWithResizableBuffer" />.</value>
    </member>
    <member name="M:UtilPack.StreamWriterWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)">
      <summary>
            Asynchronously creates a new <see cref="T:UtilPack.InnerStreamWriterWithResizableBufferAndLimitedSize" /> with given byte limit.
            This <see cref="T:UtilPack.StreamWriterWithResizableBuffer" /> will become unusable until the <see cref="M:System.IDisposable.Dispose" /> method is called on returned <see cref="T:UtilPack.InnerStreamWriterWithResizableBufferAndLimitedSize" />.
            </summary>
      <param name="byteLimit">The maximum amount of bytes that returned <see cref="T:UtilPack.InnerStreamWriterWithResizableBufferAndLimitedSize" /> may write to underlying <see cref="T:System.IO.Stream" />.</param>
      <returns>The task which will result in <see cref="T:UtilPack.InnerStreamWriterWithResizableBufferAndLimitedSize" />.</returns>
      <exception cref="T:System.InvalidOperationException">If this stream writer is currently unusable (concurrent write or usage of nested buffer created by <see cref="M:UtilPack.StreamWriterWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)" />).</exception>
    </member>
    <member name="T:UtilPack.StreamWriterWithResizableBufferAndLimitedSize">
      <summary>
            This interface further specializes <see cref="T:UtilPack.StreamWriterWithResizableBuffer" /> to include boundary on maximum amount of bytes that may be written to underlying <see cref="T:System.IO.Stream" />.
            </summary>
      <remarks>
        <see cref="T:UtilPack.StreamFactory" /> class provides methods to create objects implementing this interface.
            </remarks>
    </member>
    <member name="T:UtilPack.InnerStreamWriterWithResizableBufferAndLimitedSize">
      <summary>
            This interface augments <see cref="T:UtilPack.StreamWriterWithResizableBufferAndLimitedSize" /> interface with <see cref="M:System.IDisposable.Dispose" /> method from <see cref="T:System.IDisposable" />.
            By calling the <see cref="M:System.IDisposable.Dispose" /> method, the <see cref="T:UtilPack.StreamWriterWithResizableBuffer" /> which created this <see cref="T:UtilPack.InnerStreamWriterWithResizableBufferAndLimitedSize" /> will become useable again.
            </summary>
    </member>
    <member name="T:UtilPack.StreamFactory">
      <summary>
            This class provides methods to create instances of <see cref="T:UtilPack.StreamReaderWithResizableBuffer" />, <see cref="T:UtilPack.StreamReaderWithResizableBufferAndLimitedSize" />, <see cref="T:UtilPack.StreamWriterWithResizableBuffer" />, and <see cref="T:UtilPack.StreamWriterWithResizableBufferAndLimitedSize" />.
            </summary>
    </member>
    <member name="M:UtilPack.StreamFactory.CreateUnlimitedReader(System.IO.Stream,System.Threading.CancellationToken,UtilPack.ResizableArray{System.Byte},System.Int32)">
      <summary>
            Creates new <see cref="T:UtilPack.StreamReaderWithResizableBuffer" /> with given underlying <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="stream">The underlying <see cref="T:System.IO.Stream" /> from which to read bytes.</param>
      <param name="token">Optional <see cref="T:System.Threading.CancellationToken" /> that will be used for read operations on given <see cref="T:System.IO.Stream" />.</param>
      <param name="buffer">Optional growing buffer to use.</param>
      <param name="chunkSize">Optional maximum amount of bytes that will be read in single chunk when there is need to read from stream.</param>
      <returns>A new instance of <see cref="T:UtilPack.StreamReaderWithResizableBuffer" />.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="stream" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.StreamFactory.CreateLimitedReader(System.IO.Stream,System.Int64,System.Threading.CancellationToken,UtilPack.ResizableArray{System.Byte},System.Int32)">
      <summary>
            Creates new <see cref="T:UtilPack.StreamReaderWithResizableBufferAndLimitedSize" /> with given underlying <see cref="T:System.IO.Stream" /> and maximum amount of bytes that can be read from the stream.
            </summary>
      <param name="stream">The underlying <see cref="T:System.IO.Stream" />.</param>
      <param name="byteCount">The maximum amount of bytes that can be read from underlying <see cref="T:System.IO.Stream" />. Negative values are interpreted as <c>0</c>.</param>
      <param name="token">Optional <see cref="T:System.Threading.CancellationToken" /> that will be used for read operations on given <see cref="T:System.IO.Stream" />.</param>
      <param name="buffer">Optional growing buffer to use.</param>
      <param name="chunkSize">Optional maximum amount of bytes that will be read in single chunk when there is need to read from stream.</param>
      <returns>A new instance of <see cref="T:UtilPack.StreamReaderWithResizableBufferAndLimitedSize" />.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="byteCount" /><c> &gt; 0</c> and <paramref name="stream" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.StreamFactory.CreateUnlimitedWriter(System.IO.Stream,System.Threading.CancellationToken,UtilPack.ResizableArray{System.Byte})">
      <summary>
            Creates new <see cref="T:UtilPack.StreamWriterWithResizableBuffer" /> with given underlying <see cref="T:System.IO.Stream" /></summary>
      <param name="stream">The underlying <see cref="T:System.IO.Stream" /> to which to write bytes.</param>
      <param name="token">Optional <see cref="T:System.Threading.CancellationToken" /> that will be used for write operations on given <see cref="T:System.IO.Stream" />.</param>
      <param name="buffer">Optional growing buffer to use.</param>
      <returns>A new instance of <see cref="T:UtilPack.StreamWriterWithResizableBuffer" />.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="stream" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.StreamFactory.CreateLimitedWriter(System.IO.Stream,System.Int64,System.Threading.CancellationToken,UtilPack.ResizableArray{System.Byte})">
      <summary>
            Creates new <see cref="T:UtilPack.StreamWriterWithResizableBufferAndLimitedSize" /> with given underlying <see cref="T:System.IO.Stream" /> and maximum amount of bytse that may be written to it.
            </summary>
      <param name="stream">The underlying <see cref="T:System.IO.Stream" />.</param>
      <param name="byteCount">The maximum amount of bytes that may be written to underlying <see cref="T:System.IO.Stream" />.</param>
      <param name="token">Optional <see cref="T:System.Threading.CancellationToken" /> that will be used for write operations on given <see cref="T:System.IO.Stream" />.</param>
      <param name="buffer">Optional growing buffer to use.</param>
      <returns>A new instance of <see cref="T:UtilPack.StreamWriterWithResizableBufferAndLimitedSize" />.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="byteCount" /><c> &gt; 0</c> and <paramref name="stream" /> is <c>null</c>.</exception>
    </member>
    <member name="T:UtilPack.StringConversions">
      <summary>
            This class contains useful methods to convert things to and from strings, including e.g. hexadecimal and base64 conversions.
            </summary>
    </member>
    <member name="M:UtilPack.StringConversions.CreateHexString(System.Byte[],System.Boolean)">
      <summary>
            This method creates a textual representation in hexadecimal format of byte array <paramref name="data" />.
            </summary>
      <param name="data">Byte array to create textual representation from.</param>
      <param name="upperCaseHexes">
        <c>true</c> if alpha characters in should be in upper case; <c>false</c> otherwise.</param>
      <returns>
        <c>null</c> if <paramref name="data" /> is <c>null</c>; otherwise textual representation of the byte array in hexadecimal format.</returns>
      <remarks>This is modified version represented on <see href="http://social.msdn.microsoft.com/Forums/en-US/csharpgeneral/thread/3928b8cb-3703-4672-8ccd-33718148d1e3/" /> , Matthew Fraser's and following PZahra's posts.</remarks>
    </member>
    <member name="M:UtilPack.StringConversions.CreateHexString(System.Byte[],System.Int32,System.Int32,System.Boolean)">
      <summary>
            This method creates a textual representation in hexadecimal format of byte array <paramref name="data" />.
            </summary>
      <param name="data">Byte array to create textual representation from.</param>
      <param name="offset">Offset in the array to start reading bytes.</param>
      <param name="count">How many bytes read from array.</param>
      <param name="upperCaseHexes">
        <c>true</c> if alpha characters in should be in upper case; <c>false</c> otherwise.</param>
      <returns>
        <c>null</c> if <paramref name="data" /> is <c>null</c>; otherwise textual representation of the byte array in hexadecimal format.</returns>
      <remarks>This is modified version represented on <see href="http://social.msdn.microsoft.com/Forums/en-US/csharpgeneral/thread/3928b8cb-3703-4672-8ccd-33718148d1e3/" /> , Matthew Fraser's and following PZahra's posts.</remarks>
    </member>
    <member name="M:UtilPack.StringConversions.CreateHexBytes(System.String,System.Int32,System.Int32,System.Int32)">
      <summary>
            This method creates a byte array based on string which is assumed to be in hexadecimal format.
            </summary>
      <param name="str">The string containing byte array in hexadecimal format.</param>
      <param name="offset">The offset in string to start reading characters.</param>
      <param name="step">How many characters to skip after each successful single byte read.</param>
      <param name="tail">How many characters to leave unread at the end of the string.</param>
      <returns>A byte array containing logically same bytes as the given string in hexadecimal format.</returns>
      <remarks>This is modified version represented on <see href="http://social.msdn.microsoft.com/Forums/en-US/csharpgeneral/thread/3928b8cb-3703-4672-8ccd-33718148d1e3/" /> , Matthew Fraser's and following PZahra's posts.</remarks>
    </member>
    <member name="M:UtilPack.StringConversions.EncodeBase64(System.Byte[],System.Boolean)">
      <summary>
            Helper method to call <see cref="M:UtilPack.StringConversions.EncodeBinary(System.Byte[],System.Int32,System.Int32,System.Char[])" /> using base64-encoding.
            </summary>
      <param name="bytes">The bytes to encode.</param>
      <param name="useURLSafeEncoding">Whether to use characters safe for URL addresses for characters for indices <c>62</c> and <c>63</c>.</param>
      <returns>Base64-encoded string of <paramref name="bytes" />.</returns>
      <remarks>
            When <paramref name="useURLSafeEncoding" /> is <c>true</c>, the characters for indices <c>62</c> and <c>63</c> are <c>-</c> and <c>_</c>, respectively.
            Otherwise, the characters for indices <c>62</c> and <c>63</c> are <c>+</c> and <c>/</c>, respectively.
            </remarks>
    </member>
    <member name="M:UtilPack.StringConversions.EncodeBase64(System.Byte[],System.Int32,System.Int32,System.Boolean)">
      <summary>
            Helper method to call <see cref="M:UtilPack.StringConversions.EncodeBinary(System.Byte[],System.Int32,System.Int32,System.Char[])" /> using base64-encoding.
            </summary>
      <param name="bytes">The bytes to encode.</param>
      <param name="start">The offset where to start encoding bytes.</param>
      <param name="length">The amount of bytes to encode.</param>
      <param name="useURLSafeEncoding">Whether to use characters safe for URL addresses for characters for indices <c>62</c> and <c>63</c>.</param>
      <returns>Base64-encoded string of <paramref name="bytes" />.</returns>
      <remarks>
            When <paramref name="useURLSafeEncoding" /> is <c>true</c>, the characters for indices <c>62</c> and <c>63</c> are <c>-</c> and <c>_</c>, respectively.
            Otherwise, the characters for indices <c>62</c> and <c>63</c> are <c>+</c> and <c>/</c>, respectively.
            </remarks>
    </member>
    <member name="M:UtilPack.StringConversions.EncodeBinary(System.Byte[],System.Char[])">
      <summary>
            Encodes whole given byte array using given character array as a lookup array for each unit.
            </summary>
      <param name="bytes">The byte array to encode.</param>
      <param name="lookupTable">The lookup table to use.</param>
      <returns>Encoded string.</returns>
      <exception cref="T:System.ArgumentException">If <paramref name="lookupTable" /> is <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="bytes" /> or <paramref name="lookupTable" /> are <c>null</c>.</exception>
      <remarks>
            Currently no padding is used.
            The option to control emitting of padding is to be added in the future.
            The block size is based on the size of the lookup table, however up to 8 bits.
            So for example, in order to encode binary using radix-64 representation (e.g. base64), the lookup table should contain at least 64 and at most 127 elements.
            </remarks>
    </member>
    <member name="M:UtilPack.StringConversions.EncodeBinary(System.Byte[],System.Int32,System.Int32,System.Char[])">
      <summary>
            Encodes given byte array using given character array as a lookup array for each unit.
            </summary>
      <param name="bytes">The byte array to encode.</param>
      <param name="start">The index to start reading the array.</param>
      <param name="length">The amount of bytes to read from the array.</param>
      <param name="lookupTable">The mapping from encoding unit into its character representation. Should have (at least) one element.</param>
      <returns>String representing binary data encoded with <paramref name="lookupTable" />.</returns>
      <exception cref="T:System.ArgumentException">If <paramref name="lookupTable" /> is <c>null</c> or empty, or if <paramref name="start" /> and <paramref name="length" /> would result in reading outside array bounds.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="bytes" /> or <paramref name="lookupTable" /> are <c>null</c>.</exception>
      <remarks>
            Currently no padding is used.
            The option to control emitting of padding is to be added in the future.
            The block size is based on the size of the lookup table, however up to 8 bits.
            So for example, in order to encode binary using radix-64 representation (e.g. base64), the lookup table should contain at least 64 and at most 127 elements.
            </remarks>
    </member>
    <member name="M:UtilPack.StringConversions.DecodeBase64(System.String,System.Boolean)">
      <summary>
            Helper method to call <see cref="M:UtilPack.StringConversions.DecodeBinary(System.String,System.Int32,System.Int32[])" /> using base64-decoding.
            </summary>
      <param name="encoded">The base64-encoded string.</param>
      <param name="useURLSafeEncoding">Whether the string was encoded using characters safe for URLs, for indices <c>62</c> and <c>63</c>.</param>
      <returns>Byte array representing base64-decoded byte sequence from given string.</returns>
    </member>
    <member name="M:UtilPack.StringConversions.DecodeBinary(System.String,System.Int32,System.Int32[])">
      <summary>
            Decodes given string into a byte array.
            </summary>
      <param name="encoded">The encoded string.</param>
      <param name="unitSize">The amount of bits single character takes. This should be <c>6</c> for radix-64 encoding.</param>
      <param name="lookupTable">The lookup table for each byte. The integer value of characters in string is used as index to this array.</param>
      <returns>Byte array representing decoded byte sequence from given string.</returns>
    </member>
    <member name="M:UtilPack.StringConversions.DecodeBinary(System.String,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32[])">
      <summary>
            Decodes given string into a byte array, starting at given offset in byte array, and reading up to given byte count.
            </summary>
      <param name="encoded">The encoded string.</param>
      <param name="bytes">The byte array to decode bytes to.</param>
      <param name="bytesStart">The offset in byte array to start decoding bytes to.</param>
      <param name="bytesCount">The maximum amount of bytes to decode.</param>
      <param name="unitSize">The amount of bits single character takes. This should be <c>6</c> for radix-64 encoding.</param>
      <param name="lookupTable">The lookup table for each byte. The integer value of characters in string is used as index to this array.</param>
      <returns>Amount of bytes read.</returns>
    </member>
    <member name="M:UtilPack.StringConversions.CreateBase64EncodeLookupTable(System.Boolean)">
      <summary>
            This is helper method to generate lookup table for encoding byte arrays using normal URL-safe or unsafe base64 encoding.
            </summary>
      <param name="isURLSafe">Whether encoding should produce strings that are safe to use in URLs.</param>
      <returns>
            The standard base64 encoding array with <c>-</c> and <c>_</c> as last characters, if <paramref name="isURLSafe" /> is true.
            Otherwise the last two characters will be <c>+</c> and <c>/</c>.
            </returns>
    </member>
    <member name="M:UtilPack.StringConversions.CreateBase64EncodeLookupTable(System.Char,System.Char)">
      <summary>
            This is helper method to generate lookup table for encoding byte arrays using customized base64 encoding.
            </summary>
      <param name="char62">The character for index <c>62</c>.</param>
      <param name="char63">The character for index <c>63</c>.</param>
      <returns>The standard base64 encoding array with customized characters for indices <c>62</c> and <c>63</c>.</returns>
      <seealso cref="M:UtilPack.StringConversions.EncodeBinary(System.Byte[],System.Int32,System.Int32,System.Char[])" />
      <seealso cref="M:UtilPack.StringConversions.EncodeBase64(System.Byte[],System.Boolean)" />
    </member>
    <member name="M:UtilPack.StringConversions.CreateDecodeLookupTable(System.Char[])">
      <summary>
            This is helper method to generate lookup table for decoding strings, encoded with given look up table using various encoding methods (e.g. <see cref="M:UtilPack.StringConversions.EncodeBinary(System.Byte[],System.Int32,System.Int32,System.Char[])" />, <see cref="M:UtilPack.StringConversions.EncodeBase64(System.Byte[],System.Boolean)" />) in this class.
            </summary>
      <param name="encodeLookupTable">The table used to encode binary data.</param>
      <returns>The array with 256 elements, with character used as index giving the numerical value of it.</returns>
      <exception cref="T:System.IndexOutOfRangeException">If any character in <paramref name="encodeLookupTable" /> has its integer value 256 or greater.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="encodeLookupTable" /> is <c>null</c>.</exception>
    </member>
    <member name="T:UtilPack.IEncodingInfo">
      <summary>
            This interface encapsulates useful information about an <see cref="T:System.Text.Encoding" /> in order to enable some functionality related to parsing strings without actually allocating new <see cref="T:System.String" /> objects.
            </summary>
      <remarks>
            See also various extension methods for this interface in <see cref="T:E_UtilPack" />.
            </remarks>
    </member>
    <member name="P:UtilPack.IEncodingInfo.Encoding">
      <summary>
            Gets the <see cref="T:System.Text.Encoding" /> used to encode and decode strings.
            </summary>
      <value>The <see cref="T:System.Text.Encoding" /> used to encode and decode strings.</value>
    </member>
    <member name="P:UtilPack.IEncodingInfo.BytesPerASCIICharacter">
      <summary>
            Gets the amount of bytes used to encode one ASCII character (<c>0 ≤ ascii_char ≤ 127</c>).
            </summary>
      <value>The amount of bytes used to encode one ASCII character.</value>
    </member>
    <member name="M:UtilPack.IEncodingInfo.ReadASCIIByte(System.Byte[],System.Int32@)">
      <summary>
            This method will read one ASCII character from given byte array, increasing given index as required.
            </summary>
      <param name="array">The byte array to read ASCII character from.</param>
      <param name="idx">The index in <paramref name="array" /> where to start reading.</param>
      <returns>The <paramref name="array" />.</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
    </member>
    <member name="M:UtilPack.IEncodingInfo.WriteASCIIByte(System.Byte[],System.Int32@,System.Byte)">
      <summary>
            This method will write one ASCII character to given byte array, increasing given index as required.
            </summary>
      <param name="array">The byte array to write ASCII character to.</param>
      <param name="idx">The index in <paramref name="array" /> where ot start writing.</param>
      <param name="asciiByte">The ASCII character (<c>0 ≤ ascii_char ≤ 127</c>).</param>
      <returns>This object.</returns>
    </member>
    <member name="P:UtilPack.IEncodingInfo.MinCharByteCount">
      <summary>
            Gets the minimum amount of bytes that is required for any character.
            </summary>
      <value>The minimum amount of bytes that is required for any character.</value>
    </member>
    <member name="P:UtilPack.IEncodingInfo.MaxCharByteCount">
      <summary>
            Gets the maximum amount of bytes that is required for any character.
            </summary>
      <value>The maximum amount of bytes that is required for any character.</value>
    </member>
    <member name="T:UtilPack.UTF8EncodingInfo">
      <summary>
            This class implements <see cref="T:UtilPack.IEncodingInfo" /> for <see cref="T:System.Text.UTF8Encoding" />.
            </summary>
    </member>
    <member name="M:UtilPack.UTF8EncodingInfo.#ctor(System.Text.UTF8Encoding)">
      <summary>
            Creates new instance of <see cref="T:UtilPack.UTF8EncodingInfo" /> with optional existing instance of <see cref="T:System.Text.UTF8Encoding" />.
            </summary>
      <param name="encoding">The optional existing instance of <see cref="T:System.Text.UTF8Encoding" />.</param>
      <remarks>
            If <paramref name="encoding" /> is not given, then new instance of <see cref="T:System.Text.UTF8Encoding" /> is created, passing <c>false</c> to both boolean parameters of the <see cref="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)" /></remarks>
    </member>
    <member name="P:UtilPack.UTF8EncodingInfo.Encoding">
      <summary>
            Gets the <see cref="T:System.Text.UTF8Encoding" /> object.
            </summary>
      <value>The <see cref="T:System.Text.UTF8Encoding" /> object.</value>
    </member>
    <member name="P:UtilPack.UTF8EncodingInfo.BytesPerASCIICharacter">
      <summary>
            Returns <c>1</c>.
            </summary>
      <value>
        <c>1</c>.</value>
    </member>
    <member name="M:UtilPack.UTF8EncodingInfo.ReadASCIIByte(System.Byte[],System.Int32@)">
      <inheritdoc />
    </member>
    <member name="M:UtilPack.UTF8EncodingInfo.WriteASCIIByte(System.Byte[],System.Int32@,System.Byte)">
      <inheritdoc />
    </member>
    <member name="P:UtilPack.UTF8EncodingInfo.MinCharByteCount">
      <summary>
            Returns <c>1</c>.
            </summary>
      <value>
        <c>1</c>.</value>
    </member>
    <member name="P:UtilPack.UTF8EncodingInfo.MaxCharByteCount">
      <summary>
            Returns <c>4</c>.
            </summary>
      <value>
        <c>4</c>.</value>
    </member>
    <member name="T:UtilPack.UTF16EncodingInfo">
      <summary>
            This is abstract class for information about little-endian and big-endian UTF-16 encodings represented by <see cref="T:System.Text.UnicodeEncoding" /> class.
            </summary>
    </member>
    <member name="P:UtilPack.UTF16EncodingInfo.Encoding">
      <summary>
            Gets the <see cref="T:System.Text.UnicodeEncoding" /> object.
            </summary>
      <value>The <see cref="T:System.Text.UnicodeEncoding" /> object.</value>
    </member>
    <member name="P:UtilPack.UTF16EncodingInfo.BytesPerASCIICharacter">
      <summary>
            Returns <c>2</c>.
            </summary>
      <value>
        <c>2</c>.</value>
    </member>
    <member name="P:UtilPack.UTF16EncodingInfo.MinCharByteCount">
      <summary>
            Returns <c>2</c>.
            </summary>
      <value>
        <c>2</c>.</value>
    </member>
    <member name="P:UtilPack.UTF16EncodingInfo.MaxCharByteCount">
      <summary>
            Returns <c>2</c>.
            </summary>
      <value>
        <c>2</c>.</value>
    </member>
    <member name="M:UtilPack.UTF16EncodingInfo.ReadASCIIByte(System.Byte[],System.Int32@)">
      <summary>
            Reads one byte as ASCII byte.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index in <paramref name="array" /> to read ASCII byte from. This will be advanced by <c>2</c>.</param>
      <returns>The read ASCII byte.</returns>
    </member>
    <member name="M:UtilPack.UTF16EncodingInfo.WriteASCIIByte(System.Byte[],System.Int32@,System.Byte)">
      <summary>
            Writes one ASCII byte to given array, and clears other byte, depending on endianness.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index in <paramref name="array" /> to write character data to. This will be advanced by <c>2</c>.</param>
      <param name="asciiByte">The ASCII byte to write.</param>
      <returns>This <see cref="T:UtilPack.UTF16EncodingInfo" />.</returns>
    </member>
    <member name="T:UtilPack.UTF16LEEncodingInfo">
      <summary>
            This class contains information about little-endian UTF-16 encoding.
            </summary>
    </member>
    <member name="M:UtilPack.UTF16LEEncodingInfo.#ctor(System.Text.UnicodeEncoding)">
      <summary>
            Creates new instance of <see cref="T:UtilPack.UTF16LEEncodingInfo" />.
            </summary>
      <param name="encoding">The optional <see cref="T:System.Text.UnicodeEncoding" /> to use.</param>
      <exception cref="T:System.ArgumentException">If <paramref name="encoding" /> was specified, and it was not little-endian.</exception>
    </member>
    <member name="T:UtilPack.UTF16BEEncodingInfo">
      <summary>
            This class contains information about big-endian UTF-16 encoding.
            </summary>
    </member>
    <member name="M:UtilPack.UTF16BEEncodingInfo.#ctor(System.Text.UnicodeEncoding)">
      <summary>
            Creates new instance of <see cref="T:UtilPack.UTF16BEEncodingInfo" />.
            </summary>
      <param name="encoding">The optional <see cref="T:System.Text.UnicodeEncoding" /> to use.</param>
      <exception cref="T:System.ArgumentException">If <paramref name="encoding" /> was specified, and it was not big-endian.</exception>
    </member>
    <member name="T:UtilPack.DateTimeComparer">
      <summary>
            This class provides a way to compare <see cref="T:System.DateTime" />s with truncated precision.
            </summary>
    </member>
    <member name="P:UtilPack.DateTimeComparer.Default">
      <summary>
            Gets the default comparer for <see cref="T:System.DateTime" />, which preforms exact equality check.
            </summary>
    </member>
    <member name="M:UtilPack.DateTimeComparer.CreateComparerForTruncatedValues(System.TimeSpan)">
      <summary>
            Creates a new equality comparer which will truncate both <see cref="T:System.DateTime" />s to certain precision before performing equality check.
            </summary>
      <param name="truncatePrecision">The truncate precision.</param>
      <returns>A new equality comparer which will truncate both <see cref="T:System.DateTime" />s to certain precision before performing equality check.</returns>
      <remarks>The return value can be casted to <see cref="T:System.Collections.IEqualityComparer" />.</remarks>
    </member>
    <member name="T:UtilPack.UsingHelper">
      <summary>
            This is helper class to invoke code finally block by using <c>using</c> word in C#.
            </summary>
    </member>
    <member name="M:UtilPack.UsingHelper.#ctor(System.Action)">
      <summary>
            Creates a new instance of <see cref="T:UtilPack.UsingHelper" /> with specified action to invoke during disposing.
            </summary>
      <param name="action">The action to invoke during disposing. May be <c>null</c>.</param>
      <remarks>The <paramref name="action" /> is invoked only if <see cref="M:System.IDisposable.Dispose" /> method is called. Otherwise, e.g. when garbage collecting this object, the delegate will not be invoked.</remarks>
    </member>
    <member name="M:UtilPack.UsingHelper.Dispose(System.Boolean)">
      <inheritdoc />
    </member>
    <member name="T:E_UtilPack">
      <summary>
            This class contains extension methods for types defined in this assembly.
            </summary>
    </member>
    <member name="M:E_UtilPack.CheckForNullValues(UtilPack.NullSorting,System.Object,System.Object,System.Int32@)">
      <summary>
            This is helper method, which checks whether one or both of the given objects are <c>null</c>, and if so, assigns comparison result appropriate to this <see cref="T:UtilPack.NullSorting" /> enumeration, and returns <c>false</c>.
            If neither of the given objects are <c>null</c>, this then returns <c>true</c>.
            </summary>
      <param name="nullSortingStrategy">This <see cref="T:UtilPack.NullSorting" /> strategy.</param>
      <param name="x">The first argument to comparison.</param>
      <param name="y">The second argument to comparison.</param>
      <param name="comparisonResult">This parameter will hold the result of the comparison, if <paramref name="x" /> or <paramref name="y" /> or both are <c>null</c>.</param>
      <returns>
        <c>true</c> if <paramref name="x" /> and <paramref name="y" /> are both non-<c>null</c>; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:E_UtilPack.DisposeAsyncSafely(UtilPack.IAsyncDisposable,System.Threading.CancellationToken)">
      <summary>
            Helper method to call <see cref="M:UtilPack.IAsyncDisposable.DisposeAsync(System.Threading.CancellationToken)" /> method and ignore any exception thrown.
            </summary>
      <param name="disposable">The <see cref="T:UtilPack.IAsyncDisposable" />. May be <c>null</c>.</param>
      <param name="token">The optional cancellation token to pass to <see cref="M:UtilPack.IAsyncDisposable.DisposeAsync(System.Threading.CancellationToken)" />.</param>
      <returns>The task to await for <see cref="M:UtilPack.IAsyncDisposable.DisposeAsync(System.Threading.CancellationToken)" /> to end.</returns>
    </member>
    <member name="M:E_UtilPack.IsMidTransition``2(UtilPack.Transformable{``0,``1})">
      <summary>
            Checks whether this <see cref="T:UtilPack.Transformable`2" /> is in middle of asynchronous transition.
            </summary>
      <typeparam name="T1">The type of the initial value.</typeparam>
      <typeparam name="T2">The type of the transformed value.</typeparam>
      <param name="transformable">This <see cref="T:UtilPack.Transformable`2" />.</param>
      <returns>
        <c>true</c> if transformable is in middle of asynchronous transition; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:E_UtilPack.TryTransitionOrWaitAsync``2(UtilPack.Transformable{``0,``1},System.Func{``0,System.Threading.Tasks.Task{``1}})">
      <summary>
            Helper method to try asynchronous transition, or wait till it is complete, if it is invoked elsewhere.
            </summary>
      <typeparam name="T1">The type of the initial value.</typeparam>
      <typeparam name="T2">The type of the transformed value.</typeparam>
      <param name="transformable">This <see cref="T:UtilPack.Transformable`2" />.</param>
      <param name="transitioner">The lambda to perform transition.</param>
      <returns>The task to await to.</returns>
    </member>
    <member name="M:E_UtilPack.DisposeSafely(System.IDisposable)">
      <summary>
            Disposes the given <paramref name="disposable" /> without leaking any exceptions.
            </summary>
      <param name="disposable">The <see cref="T:System.IDisposable" /> to call <see cref="M:System.IDisposable.Dispose" /> method on. May be <c>null</c>, in which case, nothing is done.</param>
    </member>
    <member name="M:E_UtilPack.DisposeSafely(System.IDisposable,System.Exception@)">
      <summary>
            Disposes the given <paramref name="disposable" /> without leaking any exceptions, but giving out occurred exception, if any.
            </summary>
      <param name="disposable">The <see cref="T:System.IDisposable" /> to call <see cref="M:System.IDisposable.Dispose" /> method on. May be <c>null</c>, in which case, nothing is done.</param>
      <param name="exception">Will hold an exception thrown by <see cref="M:System.IDisposable.Dispose" /> method, if method is invoked and it throws.</param>
      <returns>
        <c>true</c> if NO exception occurred; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:E_UtilPack.IsTrue(System.Nullable{System.Boolean})">
      <summary>
            Checks whether given nullable boolean has value and that value is <c>true</c>.
            </summary>
      <param name="nullable">Nullable boolean.</param>
      <returns>
        <c>true</c> if <paramref name="nullable" /> has value and that value is <c>true</c>; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:E_UtilPack.IsFalse(System.Nullable{System.Boolean})">
      <summary>
            Checks whether given nullable boolean has value and that value is <c>false</c>.
            </summary>
      <param name="nullable">Nullable boolean.</param>
      <returns>
        <c>true</c> if <paramref name="nullable" /> has value and that value is <c>false</c>; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:E_UtilPack.ParseAsBooleanSafe(System.String)">
      <summary>
            Checks that string is non-<c>null</c> and equivalent to <see cref="F:System.Boolean.TrueString" />.
            </summary>
      <param name="str">The string to check.</param>
      <returns>
        <c>true</c> if <paramref name="str" /> is equivalent to <see cref="F:System.Boolean.TrueString" />; <c>false</c> otherwise.</returns>
      <remarks>
            This should be a no-throw method.
            </remarks>
    </member>
    <member name="M:E_UtilPack.GetHexadecimalValue(System.Char)">
      <summary>
            Tries to interpret this character as hexadecimal character (0-9, A-F, or a-f), and return the hexadecimal value.
            </summary>
      <param name="c">This character.</param>
      <returns>The hexadecimal value (<c>0 ≤ return_value ≤ 16</c>), or <c>null</c> if this character is not a hexadecimal character.</returns>
    </member>
    <member name="M:E_UtilPack.Truncate(System.DateTime,System.TimeSpan)">
      <summary>
            This is utility method to truncate given <see cref="T:System.DateTime" /> to a certain precision.
            </summary>
      <param name="dateTime">The <see cref="T:System.DateTime" /> to truncate.</param>
      <param name="timeSpan">The precision to use.</param>
      <returns>Truncated <see cref="T:System.DateTime" />.</returns>
      <remarks>
            The code is from <see href="http://stackoverflow.com/questions/1004698/how-to-truncate-milliseconds-off-of-a-net-datetime" />.
            </remarks>
    </member>
    <member name="M:E_UtilPack.TruncateToWholeMilliseconds(System.DateTime)">
      <summary>
            Helper method to call <see cref="M:E_UtilPack.Truncate(System.DateTime,System.TimeSpan)" /> with required argument for truncating given <see cref="T:System.DateTime" /> to whole milliseconds.
            </summary>
      <param name="dateTime">The <see cref="T:System.DateTime" /> to truncate.</param>
      <returns>a <see cref="T:System.DateTime" /> truncated to whole milliseconds.</returns>
    </member>
    <member name="M:E_UtilPack.TruncateToWholeSeconds(System.DateTime)">
      <summary>
            Helper method to call <see cref="M:E_UtilPack.Truncate(System.DateTime,System.TimeSpan)" /> with required argument for truncating given <see cref="T:System.DateTime" /> to whole seconds.
            </summary>
      <param name="dateTime">The <see cref="T:System.DateTime" /> to truncate.</param>
      <returns>a <see cref="T:System.DateTime" /> truncated to whole seconds.</returns>
    </member>
    <member name="M:E_UtilPack.TruncateToWholeMinutes(System.DateTime)">
      <summary>
            Helper method to call <see cref="M:E_UtilPack.Truncate(System.DateTime,System.TimeSpan)" /> with required argument for truncating given <see cref="T:System.DateTime" /> to whole minutes.
            </summary>
      <param name="dateTime">The <see cref="T:System.DateTime" /> to truncate.</param>
      <returns>a <see cref="T:System.DateTime" /> truncated to whole minutes.</returns>
    </member>
    <member name="M:E_UtilPack.TruncateToWholeHours(System.DateTime)">
      <summary>
            Helper method to call <see cref="M:E_UtilPack.Truncate(System.DateTime,System.TimeSpan)" /> with required argument for truncating given <see cref="T:System.DateTime" /> to whole hours.
            </summary>
      <param name="dateTime">The <see cref="T:System.DateTime" /> to truncate.</param>
      <returns>a <see cref="T:System.DateTime" /> truncated to whole hours.</returns>
    </member>
    <member name="M:E_UtilPack.TruncateToWholeDays(System.DateTime)">
      <summary>
            Helper method to call <see cref="M:E_UtilPack.Truncate(System.DateTime,System.TimeSpan)" /> with required argument for truncating given <see cref="T:System.DateTime" /> to whole days.
            </summary>
      <param name="dateTime">The <see cref="T:System.DateTime" /> to truncate.</param>
      <returns>a <see cref="T:System.DateTime" /> truncated to whole days.</returns>
    </member>
    <member name="M:E_UtilPack.GetResultOrThrow``1(UtilPack.ResultOrNone{``0})">
      <summary>
            Gets the result from <see cref="T:UtilPack.ResultOrNone`1" />, or throws it it doesn't have a result.
            </summary>
      <typeparam name="T">The type of the result.</typeparam>
      <param name="resultOrNone">The <see cref="T:UtilPack.ResultOrNone`1" />.</param>
      <returns>The result of this <see cref="T:UtilPack.ResultOrNone`1" />, if it has one.</returns>
      <exception cref="T:System.InvalidOperationException">If this <see cref="T:UtilPack.ResultOrNone`1" /> does not have a result (its <see cref="P:UtilPack.ResultOrNone`1.HasResult" /> property is <c>false</c>).</exception>
    </member>
    <member name="M:E_UtilPack.IsNullable(System.Type,System.Type@)">
      <summary>
            Checks whether <paramref name="type" /> is non-<c>null</c> and a nullable type.
            If so, the <paramref name="paramType" /> will contain the underlying value type of the value type.
            </summary>
      <param name="type">The type to check.</param>
      <param name="paramType">This will contain underlying value type if this method returns <c>true</c>; otherwise it will be <paramref name="type" />.</param>
      <returns>If the <paramref name="type" /> is non-<c>null</c> and nullable type, <c>true</c>; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:E_UtilPack.IsLazy(System.Type)">
      <summary>
            Checks whether <paramref name="type" /> is non-<c>null</c> and lazy type (instance of <see cref="T:System.Lazy`1" />).
            </summary>
      <param name="type">Type to check.</param>
      <returns>
        <c>true</c> if <paramref name="type" /> is non-<c>null</c> and lazy type; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:E_UtilPack.IsLazy(System.Type,System.Type@)">
      <summary>
            Checks whether <paramref name="type" /> is non-<c>null</c> and lazy type (instance of <see cref="T:System.Lazy`1" />).
            If so, the <paramref name="paramType" /> will contain the underlying type of the lazy type.
            </summary>
      <param name="type">The type to check.</param>
      <param name="paramType">This will contain underlying type of lazy type if this method returns <c>true</c>; otherwise it will be <paramref name="type" />.</param>
      <returns>
        <c>true</c> if <paramref name="type" /> is non-<c>null</c> and lazy type; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:E_UtilPack.IsNullable(System.Type)">
      <summary>
            Checks whether <paramref name="type" /> is non-<c>null</c> and a nullable type.
            </summary>
      <param name="type">Type to check.</param>
      <returns>
        <c>true</c> if <paramref name="type" /> is non-<c>null</c> and nullable type; <c>false</c> otherwise.</returns>
    </member>
    <member name="M:E_UtilPack.InvokeAndWaitForAwaitables``2(UtilPack.GenericEventHandler{``0},``1)">
      <summary>
            Helper method to invoke the event and then wait for any awaitables stored to the list of <see cref="T:UtilPack.EventArgsWithAsyncContextImpl" />.
            </summary>
      <typeparam name="TEventArgs">The declared type of event args, must implement <see cref="T:UtilPack.EventArgsWithAsyncContext" />.</typeparam>
      <typeparam name="TActualEventArgs">The actual type of event args, must inherit <see cref="T:UtilPack.EventArgsWithAsyncContextImpl" /> and <typeparamref name="TEventArgs" />.</typeparam>
      <param name="evt">The event, may be <c>null</c>.</param>
      <param name="args">The event arguments to be passed to event.</param>
      <returns>The task to await for.</returns>
    </member>
    <member name="M:E_UtilPack.GetMultiplexedValueOrDefault``2(UtilPack.Multiplexer{``0,``1},``0)">
      <summary>
            Gets the multiplexed value for given key.
            </summary>
      <param name="multiplexer">The <see cref="T:UtilPack.Multiplexer`2" />.</param>
      <param name="key">The key.</param>
      <returns>The multiplexed value for <paramref name="key" />, or default value of type <typeparamref name="TValue" /> nothing is multiplexed for <paramref name="key" />.</returns>
      <typeparam name="TKey">The key type of the <see cref="T:UtilPack.Multiplexer`2" />.</typeparam>
      <typeparam name="TValue">The value type of the <see cref="T:UtilPack.Multiplexer`2" />.</typeparam>
    </member>
    <member name="M:E_UtilPack.EnsureThatCanAdd``1(UtilPack.ResizableArray{``0},System.Int32,System.Int32)">
      <summary>
            Helper method to ensure that given <see cref="T:UtilPack.ResizableArray`1" /> will have at least <paramref name="currentIndex" /> + <paramref name="amountToAdd" /> elements.
            </summary>
      <typeparam name="T">The type of elements in <paramref name="array" />.</typeparam>
      <param name="array">The <see cref="T:UtilPack.ResizableArray`1" />.</param>
      <param name="currentIndex">The current index of array.</param>
      <param name="amountToAdd">The amount of elements to add.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteArray``1(UtilPack.ResizableArray{``0},System.Int32@,``0[])">
      <summary>
            Writes contents of <paramref name="sourceArray" /> to this <see cref="T:UtilPack.ResizableArray`1" />.
            </summary>
      <typeparam name="T">The type of elements in the <paramref name="array" />.</typeparam>
      <param name="array">The <see cref="T:UtilPack.ResizableArray`1" /></param>
      <param name="idx">The offset at which to start copying elements into the <paramref name="array" />.</param>
      <param name="sourceArray">The array to read elements from. May be <c>null</c>.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteArray``1(UtilPack.ResizableArray{``0},System.Int32@,``0[],System.Int32)">
      <summary>
            Writes given amount of elements from <paramref name="sourceArray" /> into this <see cref="T:UtilPack.ResizableArray`1" /></summary>
      <typeparam name="T">The type of elements in the <paramref name="array" />.</typeparam>
      <param name="array">The <see cref="T:UtilPack.ResizableArray`1" /></param>
      <param name="idx">The offset at which to start copying elements into the <paramref name="array" />.</param>
      <param name="sourceArray">The array to read elements from.</param>
      <param name="count">The amount of elements to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteArray``1(UtilPack.ResizableArray{``0},System.Int32@,``0[],System.Int32,System.Int32)">
      <summary>
            Starting at given offset, writes given amount of elements from <paramref name="sourceArray" /> into this <see cref="T:UtilPack.ResizableArray`1" /></summary>
      <typeparam name="T">The type of elements in the <paramref name="array" />.</typeparam>
      <param name="array">The <see cref="T:UtilPack.ResizableArray`1" /></param>
      <param name="idx">The offset at which to start copying elements into the <paramref name="array" />.</param>
      <param name="sourceArray">The array to read elements from.</param>
      <param name="offset">The offset at which to start reading elements from <paramref name="sourceArray" />.</param>
      <param name="count">The amount of elements to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteByteToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.Byte)">
      <summary>
            Sets a single byte in byte array at specified offset to given value, and increments the offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to set byte. Will be incremented by 1.</param>
      <param name="value">The value to set.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteSByteToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.SByte)">
      <summary>
            Sets a single byte in byte array at specified offset to given value, and increments the offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to set byte. Will be incremented by 1.</param>
      <param name="value">The value to set. Even though it is integer, it is interpreted as signed byte.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteInt16LEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.Int16)">
      <summary>
            Writes a given <see cref="T:System.Int16" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 2.</param>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteInt16LEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.Int16)">
      <summary>
            Writes a given <see cref="T:System.Int16" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteUInt16LEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.UInt16)">
      <summary>
            Writes a given <see cref="T:System.UInt16" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 2.</param>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteUInt16LEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.UInt16)">
      <summary>
            Writes a given <see cref="T:System.UInt16" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteInt32LEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.Int32)">
      <summary>
            Writes a given <see cref="T:System.Int32" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 4.</param>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteInt32LEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.Int32)">
      <summary>
            Writes a given <see cref="T:System.Int32" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteUInt32LEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.UInt32)">
      <summary>
            Writes a given <see cref="T:System.UInt32" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 4.</param>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteUInt32LEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.UInt32)">
      <summary>
            Writes a given <see cref="T:System.UInt32" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteInt64LEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.Int64)">
      <summary>
            Writes a given <see cref="T:System.Int64" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 8.</param>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteInt64LEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.Int64)">
      <summary>
            Writes a given <see cref="T:System.Int64" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteUInt64LEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.UInt64)">
      <summary>
            Writes a given <see cref="T:System.UInt64" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 8.</param>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteUInt64LEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.UInt64)">
      <summary>
            Writes a given <see cref="T:System.UInt64" /> in byte array starting at specified offset, using little-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteSingleLEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.Single)">
      <summary>
            Writes Int32 bits of given <see cref="T:System.Single" /> value in little-endian orger to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 4.</param>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteSingleLEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.Single)">
      <summary>
            Writes Int32 bits of given <see cref="T:System.Single" /> value in little-endian orger to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteDoubleLEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.Double)">
      <summary>
            Writes Int64 bits of given <see cref="T:System.Double" /> value in little-endian order to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 8.</param>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteDoubleLEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.Double)">
      <summary>
            Writes Int64 bits of given <see cref="T:System.Double" /> value in little-endian order to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteInt16BEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.Int16)">
      <summary>
            Writes a given <see cref="T:System.Int16" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 2.</param>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteInt16BEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.Int16)">
      <summary>
            Writes a given <see cref="T:System.Int16" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteUInt16BEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.UInt16)">
      <summary>
            Writes a given <see cref="T:System.UInt16" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 2.</param>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteUInt16BEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.UInt16)">
      <summary>
            Writes a given <see cref="T:System.UInt16" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteInt32BEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.Int32)">
      <summary>
            Writes a given <see cref="T:System.Int32" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 4.</param>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteInt32BEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.Int32)">
      <summary>
            Writes a given <see cref="T:System.Int32" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteUInt32BEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.UInt32)">
      <summary>
            Writes a given <see cref="T:System.UInt32" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 4.</param>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteUInt32BEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.UInt32)">
      <summary>
            Writes a given <see cref="T:System.UInt32" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteInt64BEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.Int64)">
      <summary>
            Writes a given <see cref="T:System.Int64" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 8.</param>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteInt64BEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.Int64)">
      <summary>
            Writes a given <see cref="T:System.Int64" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteUInt64BEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.UInt64)">
      <summary>
            Writes a given <see cref="T:System.UInt64" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 8.</param>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteUInt64BEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.UInt64)">
      <summary>
            Writes a given <see cref="T:System.UInt64" /> in byte array starting at specified offset, using big-endian encoding.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteSingleBEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.Single)">
      <summary>
            Writes Int32 bits of given <see cref="T:System.Single" /> value in big-endian orger to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 4.</param>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteSingleBEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.Single)">
      <summary>
            Writes Int32 bits of given <see cref="T:System.Single" /> value in big-endian orger to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteDoubleBEToBytes(UtilPack.ResizableArray{System.Byte},System.Int32@,System.Double)">
      <summary>
            Writes Int64 bits of given <see cref="T:System.Double" /> value in big-endian order to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing. Will be incremented by 8.</param>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.WriteDoubleBEToBytesNoRef(UtilPack.ResizableArray{System.Byte},System.Int32,System.Double)">
      <summary>
            Writes Int64 bits of given <see cref="T:System.Double" /> value in big-endian order to given array starting at specified offset.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The offset to start writing.</param>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.ZeroOut(UtilPack.ResizableArray{System.Byte},System.Int32@,System.Int32)">
      <summary>
            Fills array with zeroes, starting at specified offset and writing specified amount of zeroes.
            </summary>
      <param name="array">The byte array.</param>
      <param name="idx">The index to start. Will be incremented by <paramref name="count" /> when this method finishes.</param>
      <param name="count">The amount of zeroes to write.</param>
      <returns>The <paramref name="array" />.</returns>
    </member>
    <member name="M:E_UtilPack.Fill``1(UtilPack.ResizableArray{``0},``0[])">
      <summary>
            This is method to quickly fill array with values, utilizing the fact that <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> methods are very, very fast.
            </summary>
      <typeparam name="T">The type of array elements.</typeparam>
      <param name="destinationArray">The array to be filled with values.</param>
      <param name="value">The values to fill array with.</param>
      <returns>The <paramref name="destinationArray" /></returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="destinationArray" /> or <paramref name="value" /> are null.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="destinationArray" /> is not empty, and length of <paramref name="value" /> is greater than length of <paramref name="destinationArray" />.</exception>
    </member>
    <member name="M:E_UtilPack.FillWithNulls``1(UtilPack.ResizableArray{``0})">
      <summary>
            This is helper method to fill some class-based array with <c>null</c>s.
            Since the call <c>array.Fill(null)</c> will cause the actual array to be <c>null</c> instead of creating an array with <c>null</c> value.
            </summary>
      <typeparam name="T">The type of array elements.</typeparam>
      <param name="destinationArray">The array to be filled with values.</param>
      <returns>The <paramref name="destinationArray" /></returns>
    </member>
    <member name="M:E_UtilPack.FillWithOffset``1(UtilPack.ResizableArray{``0},System.Int32,``0[])">
      <summary>
            This is method to quickly fill array with values, utilizing the fact that <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> methods are very, very fast.
            </summary>
      <typeparam name="T">The type of array elements.</typeparam>
      <param name="destinationArray">The array to be filled with values.</param>
      <param name="value">The values to fill array with.</param>
      <param name="offset">The offset at which to start filling array.</param>
      <returns>The <paramref name="destinationArray" /></returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="destinationArray" /> or <paramref name="value" /> are null.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="destinationArray" /> is not empty, and length of <paramref name="value" /> is greater than length of <paramref name="destinationArray" />.</exception>
    </member>
    <member name="M:E_UtilPack.FillWithOffsetAndCount``1(UtilPack.ResizableArray{``0},System.Int32,System.Int32,``0[])">
      <summary>
            This is method to quickly fill array with values, utilizing the fact that <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> methods are very, very fast.
            </summary>
      <typeparam name="T">The type of array elements.</typeparam>
      <param name="destinationArray">The array to be filled with values.</param>
      <param name="value">The values to fill array with.</param>
      <param name="offset">The offset at which to start filling array.</param>
      <param name="count">How many items to fill.</param>
      <returns>The <paramref name="destinationArray" /></returns>
      <remarks>
            Original source code is found at <see href="http://stackoverflow.com/questions/5943850/fastest-way-to-fill-an-array-with-a-single-value" /> and <see href="http://coding.grax.com/2014/04/better-array-fill-function.html" />.
            According to first link, "<c>In my test with 20,000,000 array items, this function is twice as fast as a for loop.</c>".
            The source code was modified to fix a bug and also to support offset and count parameters.
            </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="destinationArray" /> or <paramref name="value" /> are null.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="destinationArray" /> is not empty, and length of <paramref name="value" /> is greater than length of <paramref name="destinationArray" />.</exception>
    </member>
    <member name="M:E_UtilPack.SetCapacityAndReturnArray``1(UtilPack.ResizableArray{``0},System.Int32)">
      <summary>
            Helper function to set <see cref="P:UtilPack.ResizableArray`1.CurrentMaxCapacity" /> and then return the <see cref="P:UtilPack.ResizableArray`1.Array" />.
            </summary>
      <typeparam name="T">The type of the array.</typeparam>
      <param name="array">The <see cref="T:UtilPack.ResizableArray`1" /></param>
      <param name="capacity">The capacity.</param>
      <returns>The <see cref="P:UtilPack.ResizableArray`1.Array" />, which will be at least the size of given <paramref name="capacity" />.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.ResizableArray`1" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.ReadNextAsync``2(UtilPack.PotentiallyAsyncReaderLogic{System.Nullable{``0},``1},``1)">
      <summary>
            Helper method to try to read next character from <typeparamref name="TSource" />, or throw if no more characters can be read.
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
      <typeparam name="TSource">The type of the source of this <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" />.</typeparam>
      <param name="reader">This <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" />.</param>
      <param name="source">The <typeparamref name="TSource" /> to read from.</param>
      <returns>A task which will return character read.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" /> is <c>null</c>.</exception>
      <exception cref="T:System.IO.EndOfStreamException">If no more characters could be read from the source.</exception>
    </member>
    <member name="M:E_UtilPack.ReadNextAsync``1(UtilPack.PotentiallyAsyncReader{System.Nullable{``0}})">
      <summary>
            Helper method to try to read next character from bound <see cref="T:UtilPack.PotentiallyAsyncReader`1" />, or throw if no more characters can be read.
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
      <param name="reader">This <see cref="T:UtilPack.PotentiallyAsyncReader`1" />.</param>
      <returns>A task which will return character read.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.PotentiallyAsyncReader`1" /> is <c>null</c>.</exception>
      <exception cref="T:System.IO.EndOfStreamException">If no more characters could be read from the source.</exception>
    </member>
    <member name="M:E_UtilPack.TryReadUntilAsync``2(UtilPack.PotentiallyAsyncReaderLogic{System.Nullable{``0},``1},``1,System.Func{``0,System.Boolean})">
      <summary>
            Helper method to try to read next value from <typeparamref name="TSource" /> until suitable value has been read, or values will end.
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
      <typeparam name="TSource">The type of the source of this <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" />.</typeparam>
      <param name="reader">This <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" />.</param>
      <param name="source">The <typeparamref name="TSource" /> to read from.</param>
      <param name="checker">Optional callback to check value. If it is supplied, this method will keep reading values until this callback returns <c>true</c>.</param>
      <returns>A task which will return last value read.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.ReadUntilAsync``2(UtilPack.PotentiallyAsyncReaderLogic{System.Nullable{``0},``1},``1,System.Func{``0,System.Boolean})">
      <summary>
            Helper method to try to read next value from <typeparamref name="TSource" />, or throw if no more values can be read.
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
      <typeparam name="TSource">The type of the source of this <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" />.</typeparam>
      <param name="reader">This <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" />.</param>
      <param name="source">The <typeparamref name="TSource" /> to read from.</param>
      <param name="checker">Optional callback to check value. If it is supplied, this method will keep reading values until this callback returns <c>true</c>.</param>
      <returns>A task which will return last value read.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.PotentiallyAsyncReaderLogic`2" /> is <c>null</c>.</exception>
      <exception cref="T:System.IO.EndOfStreamException">If no more values could be read from the source.</exception>
    </member>
    <member name="M:E_UtilPack.TryReadUntilAsync``1(UtilPack.PotentiallyAsyncReader{System.Nullable{``0}},System.Func{``0,System.Boolean})">
      <summary>
            Helper method to try to read next value from this <see cref="T:UtilPack.PotentiallyAsyncReader`1" /> until suitable value has been read, or values will end.
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
      <param name="reader">This <see cref="T:UtilPack.PotentiallyAsyncReader`1" />.</param>
      <param name="checker">Optional callback to check value. If it is supplied, this method will keep reading values until this callback returns <c>true</c>.</param>
      <returns>A task which will return last value read.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.PotentiallyAsyncReader`1" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.ReadUntilAsync``1(UtilPack.PotentiallyAsyncReader{System.Nullable{``0}},System.Func{``0,System.Boolean})">
      <summary>
            Helper method to try to read next value from this <see cref="T:UtilPack.PotentiallyAsyncReader`1" />, or throw if no more values can be read.
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
      <param name="reader">This <see cref="T:UtilPack.PotentiallyAsyncReader`1" />.</param>
      <param name="checker">Optional callback to check value. If it is supplied, this method will keep reading values until this callback returns <c>true</c>.</param>
      <returns>A task which will return last value read.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.PotentiallyAsyncReader`1" /> is <c>null</c>.</exception>
      <exception cref="T:System.IO.EndOfStreamException">If no more values could be read from the source.</exception>
    </member>
    <member name="M:E_UtilPack.TryPeekUntilAsync``1(UtilPack.PeekablePotentiallyAsyncReader{System.Nullable{``0}},System.Func{``0,System.Boolean})">
      <summary>
            Helper method to try to peek next value from this <see cref="T:UtilPack.PeekablePotentiallyAsyncReader`1" /> until suitable value has been read, or values will end.
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
      <param name="reader">This <see cref="T:UtilPack.PeekablePotentiallyAsyncReader`1" />.</param>
      <param name="checker">Optional callback to check value. If it is supplied, this method will keep reading values until this callback returns <c>true</c>.</param>
      <returns>A task which will return last value peeked.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.PeekablePotentiallyAsyncReader`1" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.PeekUntilAsync``1(UtilPack.PeekablePotentiallyAsyncReader{System.Nullable{``0}},System.Func{``0,System.Boolean})">
      <summary>
            Helper method to try to peek next value from this <see cref="T:UtilPack.PeekablePotentiallyAsyncReader`1" />, or throw if no more values can be read.
            </summary>
      <typeparam name="TValue">The type of values that this reader produces.</typeparam>
      <param name="reader">This <see cref="T:UtilPack.PeekablePotentiallyAsyncReader`1" />.</param>
      <param name="checker">Optional callback to check value. If it is supplied, this method will keep reading values until this callback returns <c>true</c>.</param>
      <returns>A task which will return last value peeked.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.PeekablePotentiallyAsyncReader`1" /> is <c>null</c>.</exception>
      <exception cref="T:System.IO.EndOfStreamException">If no more values could be read from the source.</exception>
    </member>
    <member name="M:E_UtilPack.TryReadMore``1(UtilPack.MemorizingPotentiallyAsyncReader{System.Nullable{``0},``0},System.Int32)">
      <summary>
            Tries to read more items into the buffer of this <see cref="T:UtilPack.MemorizingPotentiallyAsyncReader`2" />.
            </summary>
      <param name="reader">This <see cref="T:UtilPack.MemorizingPotentiallyAsyncReader`2" />.</param>
      <param name="amountToRead">The amount of items to read.</param>
      <returns>A task which will tell how many items were actually read.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.MemorizingPotentiallyAsyncReader`2" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.ReadMoreOrThrow``1(UtilPack.MemorizingPotentiallyAsyncReader{System.Nullable{``0},``0},System.Int32)">
      <summary>
            Read more items into the buffer of this <see cref="T:UtilPack.MemorizingPotentiallyAsyncReader`2" />, or throws if not enough items could be read.
            </summary>
      <param name="reader">This <see cref="T:UtilPack.MemorizingPotentiallyAsyncReader`2" />.</param>
      <param name="amountToRead">The amount of items to read.</param>
      <returns>A task always returning <c>true</c>.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.MemorizingPotentiallyAsyncReader`2" /> is <c>null</c>.</exception>
      <exception cref="T:System.IO.EndOfStreamException">If not enough items could be read.</exception>
    </member>
    <member name="M:E_UtilPack.ClearStreamWhenStreamBufferTooBig``1(UtilPack.PotentiallyAsyncReader{``0},UtilPack.StreamReaderWithResizableBuffer,System.Int32)">
      <summary>
            This helper method will make this <see cref="T:UtilPack.PotentiallyAsyncReader`1" /> clear the underlying buffer of <see cref="T:UtilPack.StreamReaderWithResizableBuffer" /> becomes greater or equal to than given limit, until the <see cref="M:System.IDisposable.Dispose" /> method is called.
            </summary>
      <param name="reader">This <see cref="T:UtilPack.PotentiallyAsyncReader`1" />.</param>
      <param name="source">The <see cref="T:UtilPack.StreamReaderWithResizableBuffer" /> to clear after each character read.</param>
      <param name="maxCount">The maximum amount of bytes that can be seen in <paramref name="source" />.</param>
      <returns>The <see cref="T:System.IDisposable" /> to specify a segment of code which will cause underlying stream buffer to empty after each character read.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.PotentiallyAsyncReader`1" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.ReadAllBytesToBuffer(UtilPack.StreamReaderWithResizableBuffer)">
      <summary>
            Helper method to read all the remaining bytes in underlying <see cref="T:System.IO.Stream" /> into the <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" /> of this <see cref="T:UtilPack.StreamReaderWithResizableBuffer" />.
            </summary>
      <param name="stream">This <see cref="T:UtilPack.StreamReaderWithResizableBuffer" />.</param>
      <returns>Task which completes when the last byte has been read into <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" />, returning amount of bytes read.</returns>
      <exception cref="T:System.NullReferenceException">If this <paramref name="stream" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArithmeticException">If there are more bytes left than can be fit into 32-bit integer.</exception>
    </member>
    <member name="M:E_UtilPack.ReadAllBytesToBuffer(UtilPack.StreamReaderWithResizableBufferAndLimitedSize)">
      <summary>
            Helper method to read all the reamining bytes of this <see cref="T:UtilPack.StreamReaderWithResizableBufferAndLimitedSize" /> into the <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" />.
            </summary>
      <param name="stream">This <see cref="T:UtilPack.StreamReaderWithResizableBufferAndLimitedSize" />.</param>
      <returns>Task which completes when the last byte has been read into <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" />, always returning <c>true</c>.</returns>
      <exception cref="T:System.NullReferenceException">If this <paramref name="stream" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArithmeticException">If the value of <see cref="P:UtilPack.LimitedSizeInfo.TotalByteCount" /> of this <paramref name="stream" /> can not fit into 32-bit integer.</exception>
    </member>
    <member name="M:E_UtilPack.SkipThroughRemainingBytes(UtilPack.StreamReaderWithResizableBuffer)">
      <summary>
            Helper method to skip through the remaining bytes of <see cref="T:UtilPack.StreamReaderWithResizableBuffer" />.
            </summary>
      <param name="stream">This <see cref="T:UtilPack.StreamReaderWithResizableBuffer" />.</param>
      <returns>Task which completes when the last available byte has been read into <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" />, always returning <c>true</c>.</returns>
      <exception cref="T:System.NullReferenceException">If this <paramref name="stream" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.ReadMoreOrThrow(UtilPack.StreamReaderWithResizableBuffer,System.Int32)">
      <summary>
            Helper method to read and append specific amount of bytes, and throw an <see cref="T:System.IO.EndOfStreamException" /> if the limit of this <paramref name="stream" /> has been encountered.
            </summary>
      <param name="stream">This <see cref="T:UtilPack.StreamReaderWithResizableBuffer" />.</param>
      <param name="count">The amount of bytes to read and append to buffer.</param>
      <returns>Task which completes when last of the required bytes has been read into <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" />, always returning <c>true</c>.</returns>
      <exception cref="T:System.NullReferenceException">If this <paramref name="stream" /> is <c>null</c>.</exception>
      <exception cref="T:System.IO.EndOfStreamException">If <see cref="M:UtilPack.StreamReaderWithResizableBuffer.TryReadMoreAsync(System.Int32)" /> method returns <c>false</c>.</exception>
    </member>
    <member name="M:E_UtilPack.ReadOrThrow(UtilPack.StreamReaderWithResizableBuffer,System.Int32)">
      <summary>
            Helper method to read specific amount of bytes, and throw an <see cref="T:System.IO.EndOfStreamException" /> if the limit of this <paramref name="stream" /> has been encountered.
            </summary>
      <param name="stream">This <see cref="T:UtilPack.StreamReaderWithResizableBuffer" />.</param>
      <param name="count">The amount of bytes to read and overwrite to buffer.</param>
      <returns>Task which completes when last of the required bytes has been read into <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" />, always returning <c>true</c>.</returns>
      <exception cref="T:System.NullReferenceException">If this <paramref name="stream" /> is <c>null</c>.</exception>
      <exception cref="T:System.IO.EndOfStreamException">If <see cref="M:UtilPack.StreamReaderWithResizableBuffer.TryReadAsync(System.Int32)" /> returns <c>false</c>.</exception>
    </member>
    <member name="M:E_UtilPack.ReadSpecificAmountAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
      <summary>
            Helper method to read specific amount of bytes from <see cref="T:System.IO.Stream" /> into byte array.
            </summary>
      <param name="stream">The stream to read bytes from.</param>
      <param name="array">The byte array to read bytes to.</param>
      <param name="offset">The offset where to start writing.</param>
      <param name="count">The amount of bytes to read.</param>
      <param name="token">The <see cref="T:System.Threading.CancellationToken" /> to use with stream operations.</param>
      <returns>Task which completes when last of the required bytes has been read into array, always returning <c>true</c>.</returns>
      <exception cref="T:System.NullReferenceException">If <paramref name="stream" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="offset" /> and <paramref name="count" /> are incorrect.</exception>
      <exception cref="T:System.IO.EndOfStreamException">If end of stream encountered before given <paramref name="count" /> amount of bytes could be read.</exception>
    </member>
    <member name="M:E_UtilPack.TryReadSpecificAmountAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
      <summary>
            Helper method to try to read specific amount of bytes from <see cref="T:System.IO.Stream" /> into byte array.
            </summary>
      <param name="stream">The stream to read bytes from.</param>
      <param name="array">The byte array to read bytes to.</param>
      <param name="offset">The offset where to start writing.</param>
      <param name="count">The amount of bytes to read.</param>
      <param name="token">The <see cref="T:System.Threading.CancellationToken" /> to use with stream operations.</param>
      <returns>Task which completes when last of the required bytes has been read into array, always returning <c>true</c>.</returns>
      <exception cref="T:System.NullReferenceException">If <paramref name="stream" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="offset" /> and <paramref name="count" /> are incorrect.</exception>
    </member>
    <member name="M:E_UtilPack.TryReadSpecificAmountAsync(System.IO.Stream,UtilPack.ResizableArray{System.Byte},System.Int32,System.Int32,System.Threading.CancellationToken)">
      <summary>
            Helper method to read specific amount of bytes from <see cref="T:System.IO.Stream" /> into <see cref="T:UtilPack.ResizableArray`1" />.
            The max capacity of <see cref="T:UtilPack.ResizableArray`1" /> will be increased if needed in order to fit the bytes.
            </summary>
      <param name="stream">The stream to read bytes from.</param>
      <param name="array">The byte array to read bytes to.</param>
      <param name="offset">The offset where to start writing.</param>
      <param name="count">The amount of bytes to read.</param>
      <param name="token">The <see cref="T:System.Threading.CancellationToken" /> to use with stream operations.</param>
      <returns>Task which completes when last of the required bytes has been read into array, always returning <c>true</c>.</returns>
      <exception cref="T:System.NullReferenceException">If <paramref name="stream" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="offset" /> and <paramref name="count" /> are incorrect.</exception>
      <exception cref="T:System.IO.EndOfStreamException">If end of stream encountered before given <paramref name="count" /> amount of bytes could be read.</exception>
    </member>
    <member name="M:E_UtilPack.ReadSpecificAmountAsync(System.IO.Stream,UtilPack.ResizableArray{System.Byte},System.Int32,System.Int32,System.Threading.CancellationToken)">
      <summary>
            Helper method to try to read specific amount of bytes from <see cref="T:System.IO.Stream" /> into <see cref="T:UtilPack.ResizableArray`1" />.
            The max capacity of <see cref="T:UtilPack.ResizableArray`1" /> will be increased if needed in order to fit the bytes.
            </summary>
      <param name="stream">The stream to read bytes from.</param>
      <param name="array">The byte array to read bytes to.</param>
      <param name="offset">The offset where to start writing.</param>
      <param name="count">The amount of bytes to read.</param>
      <param name="token">The <see cref="T:System.Threading.CancellationToken" /> to use with stream operations.</param>
      <returns>Task which completes when last of the required bytes has been read into array, always returning <c>true</c>.</returns>
      <exception cref="T:System.NullReferenceException">If <paramref name="stream" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="offset" /> and <paramref name="count" /> are incorrect.</exception>
    </member>
    <member name="M:E_UtilPack.AppendToBytes(UtilPack.StreamWriterWithResizableBuffer,System.Int32,System.Action{System.Byte[],System.Int32,System.Int32})">
      <summary>
            This method tries to grow the <see cref="P:UtilPack.AbstractStreamWithResizableBuffer.Buffer" /> by given <paramref name="count" />, and then invokes lambda to append to bytes.
            </summary>
      <param name="writer">This <see cref="T:UtilPack.StreamWriterWithResizableBuffer" />.</param>
      <param name="count">The amount of bytes to append.</param>
      <param name="appender">The lambda to append the bytes.</param>
      <returns>The actual amount of bytes that will be taken into account when using <see cref="M:UtilPack.StreamWriterWithResizableBuffer.FlushAsync" />.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.StreamWriterWithResizableBuffer" /> is <c>null</c>.</exception>
      <exception cref="T:System.InvalidOperationException">If this stream writer is currently unusable (concurrent write or usage of nested buffer created by <see cref="M:UtilPack.StreamWriterWithResizableBuffer.CreateWithLimitedSizeAndSharedBuffer(System.Int64)" />).</exception>
    </member>
    <member name="M:E_UtilPack.ParseInt32Textual(UtilPack.IEncodingInfo,System.Byte[],System.Int32@,System.Nullable{System.})">
      <summary>
            Parses ASCII integer string to 32-bit integer from encoded string without allocating a string.
            Negative numbers are supported, as is optional <c>+</c> prefix.
            </summary>
      <param name="encoding">This <see cref="T:UtilPack.IEncodingInfo" />.</param>
      <param name="array">The byte array containing encoded string.</param>
      <param name="offset">The offset in <paramref name="array" /> where to start reading from.</param>
      <param name="charCount">The optional character count. If this parameter is specified, then this method will only read specified maximum amount of characters. Furthermore, it may be specified that number takes *exactly* the given amount of characters.</param>
      <returns>The parsed integer.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.IEncodingInfo" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="charCount" /> is specified, but the count was invalid.</exception>
      <exception cref="T:System.FormatException">If number string was malformed, or <paramref name="charCount" /> was specified with its exact match as <c>true</c> and the amount of characters read was less than specified.</exception>
    </member>
    <member name="M:E_UtilPack.ParseInt64Textual(UtilPack.IEncodingInfo,System.Byte[],System.Int32@,System.Nullable{System.})">
      <summary>
            Parses ASCII integer string to 64-bit integer from encoded string without allocating a string.
            Negative numbers are supported, as is optional <c>+</c> prefix.
            </summary>
      <param name="encoding">This <see cref="T:UtilPack.IEncodingInfo" />.</param>
      <param name="array">The byte array containing encoded string.</param>
      <param name="offset">The offset in <paramref name="array" /> where to start reading from.</param>
      <param name="charCount">The optional character count. If this parameter is specified, then this method will only read specified maximum amount of characters. Furthermore, it may be specified that number takes *exactly* the given amount of characters.</param>
      <returns>The parsed integer.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.IEncodingInfo" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="charCount" /> is specified, but the count was invalid.</exception>
      <exception cref="T:System.FormatException">If number string was malformed, or <paramref name="charCount" /> was specified with its exact match as <c>true</c> and the amount of characters read was less than specified.</exception>
    </member>
    <member name="M:E_UtilPack.TryParseInt32Textual(UtilPack.IEncodingInfo,System.Byte[],System.Int32@,System.Int32,System.Int32@,System.String@,System.Int32@)">
      <summary>
            Tries to parse ASCII integer string to 32-bit integer from encoded string without allocating a string.
            Negative numbers are supported, as is optional <c>+</c> prefix.
            </summary>
      <param name="encoding">This <see cref="T:UtilPack.IEncodingInfo" />.</param>
      <param name="array">The byte array containing encoded string.</param>
      <param name="offset">The offset in <paramref name="array" /> where to start reading from.</param>
      <param name="charCount">The optional character count. Negative values mean that no character count is specified.</param>
      <param name="result">This will contain parsed integer.</param>
      <param name="errorString">This will contain error string, if format error is encountered.</param>
      <param name="max">The offset in array which was reached when integer ended.</param>
      <returns>Whether parsing was successful.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.IEncodingInfo" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="charCount" /> is specified, but the count was invalid.</exception>
    </member>
    <member name="M:E_UtilPack.TryParseInt64Textual(UtilPack.IEncodingInfo,System.Byte[],System.Int32@,System.Int32,System.Int64@,System.String@,System.Int32@)">
      <summary>
            Tries to parse ASCII integer string to 64-bit integer from encoded string without allocating a string.
            Negative numbers are supported, as is optional <c>+</c> prefix.
            </summary>
      <param name="encoding">This <see cref="T:UtilPack.IEncodingInfo" />.</param>
      <param name="array">The byte array containing encoded string.</param>
      <param name="offset">The offset in <paramref name="array" /> where to start reading from.</param>
      <param name="charCount">The optional character count. Negative values mean that no character count is specified.</param>
      <param name="result">This will contain parsed integer.</param>
      <param name="errorString">This will contain error string, if format error is encountered.</param>
      <param name="max">The offset in array which was reached when integer ended.</param>
      <returns>Whether parsing was successful.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.IEncodingInfo" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">If <paramref name="charCount" /> is specified, but the count was invalid.</exception>
    </member>
    <member name="M:E_UtilPack.WriteIntegerTextual(UtilPack.IEncodingInfo,System.Byte[],System.Int32@,System.Int64,System.Int32)">
      <summary>
            Writes ASCII representation of given integer in decimal format to byte array using this encoding, and without allocating a string object.
            </summary>
      <param name="encoding">The <see cref="T:UtilPack.IEncodingInfo" />.</param>
      <param name="array">The byte array to write encoded number string to.</param>
      <param name="offset">The offset in <paramref name="array" /> where to start writing.</param>
      <param name="value">The integer to write textual representation of.</param>
      <param name="fixedLength">Optional fixed length specification, in characters.</param>
      <returns>The <paramref name="encoding" />.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.IEncodingInfo" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.GetTextualIntegerRepresentationSize(UtilPack.IEncodingInfo,System.Int64,System.Int32)">
      <summary>
            Calculates how many bytes the textual representation of given integer will take if encoded as string using this encoding.
            </summary>
      <param name="encoding">This <see cref="T:UtilPack.IEncodingInfo" />.</param>
      <param name="integer">The integer to calculate size of.</param>
      <param name="numberBase">The number base that will be used when writing integer. <c>10</c> by default.</param>
      <returns>The amount of bytes the textual representation of given integer wil ltake if encoded as string using this encoding.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.IEncodingInfo" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.GetTextualFractionIntegerSize(UtilPack.IEncodingInfo,System.Int64,System.Int32,System.Int32)">
      <summary>
            Calculates how many bytes the textual representation of given fraction integer part will take if encoded as string using this encoding.
            Cuts any trailing zeroes, so that result for <c>500</c> will be <c>1</c> (encoded as just <c>5</c>).
            </summary>
      <param name="encoding">This <see cref="T:UtilPack.IEncodingInfo" />.</param>
      <param name="decimalInteger">The fraction part, as <see cref="T:System.Int64" />. Negative values are treated as positive values.</param>
      <param name="maxFractionDigitCount">The maximum amount of fraction digits.</param>
      <param name="numberBase">The number base that will be used when writing the fraction digits. <c>10</c> by default.</param>
      <returns>The amount of bytes the textual representation of given fraction part will take if encoded as string using this encoding.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.IEncodingInfo" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.WriteFractionIntegerTextual(UtilPack.IEncodingInfo,System.Byte[],System.Int32@,System.Int64,System.Int32)">
      <summary>
            Writes ASCII representation of given fraction integer to byte array using this encoding, and without allocating a string object.
            Cuts any trailing zeroes, so that <c>500</c> will become <c>5</c>.
            </summary>
      <param name="encoding">The <see cref="T:UtilPack.IEncodingInfo" />.</param>
      <param name="array">The byte array to write encoded number string to.</param>
      <param name="offset">The offset in <paramref name="array" /> where to start writing.</param>
      <param name="decimalInteger">The decimal part, as <see cref="T:System.Int64" />. Negative values are treated as positive values.</param>
      <param name="maxFractionDigitCount">The maximum amount of fraction digits.</param>
      <returns>The <paramref name="encoding" />.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.IEncodingInfo" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.WriteString(UtilPack.IEncodingInfo,System.Byte[],System.Int32@,System.String)">
      <summary>
            Writes all the characters in given string to given byte array.
            </summary>
      <param name="encoding">This <see cref="T:UtilPack.IEncodingInfo" />.</param>
      <param name="array">The byte array to write ASCII string to.</param>
      <param name="offset">The offset in <paramref name="array" /> where to start writing.</param>
      <param name="str">The string to write to. If <c>null</c>, nothing will be written.</param>
      <returns>This <see cref="T:UtilPack.IEncodingInfo" />.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.IEncodingInfo" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.WriteHexDecimal(UtilPack.IEncodingInfo,System.Byte[],System.Int32@,System.Byte,System.Boolean)">
      <summary>
            Writes given byte value as two hexadecimal textual characters to given array without allocating string object.
            </summary>
      <param name="encoding">This <see cref="T:UtilPack.IEncodingInfo" />.</param>
      <param name="array">The byte array to write hexadecimal textual characters to.</param>
      <param name="idx">The offset in <paramref name="array" /> where to start writing.</param>
      <param name="value">The value to write.</param>
      <param name="upperCase">Optional parameter specifying whether alpha characters should be upper-case.</param>
      <returns>This <see cref="T:UtilPack.IEncodingInfo" />.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.IEncodingInfo" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.ReadHexDecimal(UtilPack.IEncodingInfo,System.Byte[],System.Int32@)">
      <summary>
            Reads the next two ASCII characters as hexadecimal characters and parses the value the characters represent, without allocating string object.
            </summary>
      <param name="encoding">This <see cref="T:UtilPack.IEncodingInfo" />.</param>
      <param name="array">The byte array to read hexadecimal textual charactesr from.</param>
      <param name="idx">The offset in <paramref name="array" /> where to start reading.</param>
      <returns>The decoded hexadecimal value.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.IEncodingInfo" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">If <paramref name="array" /> is <c>null</c>.</exception>
    </member>
    <member name="M:E_UtilPack.TryParseInt64TextualGenericAsync(UtilPack.PeekablePotentiallyAsyncReader{System.Nullable{System.Char}})">
      <summary>
            Tries to parse integer as from a character reader.
            </summary>
      <param name="reader">This <see cref="T:UtilPack.PeekablePotentiallyAsyncReader`1" />.</param>
      <returns>Task which either returns parsed integer value, or <c>null</c> if parsing was unsuccessful.</returns>
      <exception cref="T:System.NullReferenceException">If this <see cref="T:UtilPack.PeekablePotentiallyAsyncReader`1" /> is <c>null</c>.</exception>
    </member>
    <member name="T:UtilPack.SizeOf">
      <summary>
           Provides methods that describe sizes of various things during runtime.
        </summary>
    </member>
    <member name="M:UtilPack.SizeOf.Type``1">
      <summary>
          Gets the runtime size of the given type, in bytes.
        </summary>
      <typeparam name="TType">The type to calculate size of.</typeparam>
    </member>
    <member name="M:E_UtilPack.InvokeEventIfNotNull``1(``0,System.Action{``0})">
      <summary>
            Invokes the event if it is non-<c>null</c>.
         </summary>
      <typeparam name="TDelegate">The type of the event.</typeparam>
      <param name="del">The value of the event field.</param>
      <param name="invoker">
            The lambda to invoke non-<c>null</c> event.
         </param>
      <returns>
        <c>true</c> if <paramref name="del" /> was non-<c>null</c>; <c>false</c> otherwise.
         </returns>
    </member>
    <member name="M:E_UtilPack.InvokeAllEventHandlers``1(``0,System.Action{``0},System.Boolean)">
      <summary>
            Invokes all event handlers one by one, even if some of them throw exception.
         </summary>
      <typeparam name="TDelegate">The type of the event.</typeparam>
      <param name="del">The value of the event field.</param>
      <param name="invoker">
            The lambda to invoke non-<c>null</c> event.
         </param>
      <param name="throwExceptions">Whether this method should throw exceptions that are thrown by event handlers.</param>
      <returns>
        <c>true</c> if <paramref name="del" /> was non-<c>null</c>; <c>false</c> otherwise.
         </returns>
      <exception cref="T:System.AggregateException">
            If <paramref name="throwExceptions" /> is <c>true</c> and any of the event handler throws an exception. The exception(s) will be given to the <see cref="T:System.AggregateException" /> constructor.
         </exception>
      <remarks>
            If <paramref name="throwExceptions" /> is <c>true</c> and first exception is thrown by last event handler, then that exception is re-thrown instead of throwing <see cref="T:System.AggregateException" />.
         </remarks>
    </member>
    <member name="M:E_UtilPack.InvokeAllEventHandlers``1(``0,System.Action{``0},System.Exception[]@)">
      <summary>
            Invokes all event handlers one by one, even if some of them throw exception.
         </summary>
      <typeparam name="TDelegate">The type of the event.</typeparam>
      <param name="del">The value of the event field.</param>
      <param name="invoker">
            The lambda to invoke non-<c>null</c> event.
         </param>
      <param name="occurredExceptions">
            This will hold all exceptions thrown by event handlers. Will be <c>null</c> if no exceptions were thrown.
         </param>
      <returns>
        <c>true</c> if <paramref name="del" /> was non-<c>null</c>; <c>false</c> otherwise.
         </returns>
    </member>
    <member name="T:UtilPack.DelegateMultiplexer`2">
      <summary>This class implements <see cref="T:UtilPack.Multiplexer`2" /> with <see cref="T:System.Delegate" /> as constraint for values.</summary>
      <typeparam name="TKey">The key type.</typeparam>
      <typeparam name="TDelegate">The type of delegate.</typeparam>
      <remarks>
            This class is very useful when one multiplexes a single event, e.g. when having one <c>PropertyChanged</c> event based on property name, but allowing to register to events fired on specific property change.
            In that case, the <typeparamref name="TKey" /> would be <see cref="T:System.String" /> and <typeparamref name="TDelegate" /> would be the type of event.
         </remarks>
    </member>
    <member name="M:UtilPack.DelegateMultiplexer`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>Creates a new instance of <see cref="T:UtilPack.DelegateMultiplexer`2" /> with optional custom equality comparer for keys.</summary>
      <param name="equalityComparer">The optional custom equality comparer for keys.</param>
    </member>
    <member name="M:UtilPack.DelegateMultiplexer`2.Combine(`1,`1)">
      <inheritdoc />
    </member>
    <member name="M:UtilPack.DelegateMultiplexer`2.Remove(`1,`1)">
      <inheritdoc />
    </member>
  </members>
</doc>